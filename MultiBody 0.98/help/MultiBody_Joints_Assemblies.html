<HTML>
<HEAD><META name="HTML-Generator" content="Dymola"><TITLE>MultiBody</TITLE></HEAD>
<BODY><P>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE Assemblies<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="MultiBody.Joints.Assemblies"></A><A HREF="MultiBody_Joints.html#MultiBody.Joints"
>MultiBody.Joints</A>.Assemblies</H2>
<B>Joint aggregations for analytic loop handling</B>
<P>
<A HREF="MultiBody_Joints_Assemblies.html#MultiBody.Joints.Assemblies.JointUPS"
><IMG SRC="MultiBody.Joints.Assemblies.JointUPSI.png" ALT="MultiBody.Joints.Assemblies.JointUPS" WIDTH=80  HEIGHT=80 ></A>
<A HREF="MultiBody_Joints_Assemblies.html#MultiBody.Joints.Assemblies.JointUSR"
><IMG SRC="MultiBody.Joints.Assemblies.JointUSRI.png" ALT="MultiBody.Joints.Assemblies.JointUSR" WIDTH=80  HEIGHT=80 ></A>
<A HREF="MultiBody_Joints_Assemblies.html#MultiBody.Joints.Assemblies.JointUSP"
><IMG SRC="MultiBody.Joints.Assemblies.JointUSPI.png" ALT="MultiBody.Joints.Assemblies.JointUSP" WIDTH=80  HEIGHT=80 ></A>
<A HREF="MultiBody_Joints_Assemblies.html#MultiBody.Joints.Assemblies.JointSSR"
><IMG SRC="MultiBody.Joints.Assemblies.JointSSRI.png" ALT="MultiBody.Joints.Assemblies.JointSSR" WIDTH=80  HEIGHT=80 ></A>
<A HREF="MultiBody_Joints_Assemblies.html#MultiBody.Joints.Assemblies.JointSSP"
><IMG SRC="MultiBody.Joints.Assemblies.JointSSPI.png" ALT="MultiBody.Joints.Assemblies.JointSSP" WIDTH=80  HEIGHT=80 ></A>
<A HREF="MultiBody_Joints_Assemblies.html#MultiBody.Joints.Assemblies.JointRRR"
><IMG SRC="MultiBody.Joints.Assemblies.JointRRRI.png" ALT="MultiBody.Joints.Assemblies.JointRRR" WIDTH=80  HEIGHT=80 ></A>
<A HREF="MultiBody_Joints_Assemblies.html#MultiBody.Joints.Assemblies.JointRRP"
><IMG SRC="MultiBody.Joints.Assemblies.JointRRPI.png" ALT="MultiBody.Joints.Assemblies.JointRRP" WIDTH=80  HEIGHT=80 ></A>
<P><P>
<H3>Information</H3>
<PRE></pre>
<p>
The joints in this package are mainly designed to be used
in <b>kinematic loop</b> structures. Every component consists of
<b>3 elementary joints</b>. These joints are combined in such a
way that the kinematics of the 3 joints between frame_a and
frame_b are computed from the movement of frame_a and frame_b,
i.e., there are <b>no constraints</b> between frame_a and frame_b.
This requires to solve a <b>non-linear system of equations</b> which
is performed <b>analytically</b> (i.e., when a mathematical
solution exists, it is computed efficiently and reliably).
</p>
<p>
The assembly joints in this package are named <b>JointXYZ</b> where
<b>XYZ</b> are the first letters of the elementary joints used in the
component, in particular:
</p>
<table border=1 cellspacing=0 cellpadding=2>
  <tr><td><b>P</b></td><td>Prismatic joint</td></tr>
  <tr><td><b>R</b></td><td>Revolute joint</td></tr>
  <tr><td><b>S</b></td><td>Spherical joint</td></tr>
  <tr><td><b>U</b></td><td>Universal joint</td></tr>
</table>
<p>
For example, JointUSR is an assembly joint consisting
of a universal, a spherical and a revolute joint.
</p>
<p>
Note, no component of this package has potential states, since the
components are designed in such a way that the generalized coordinates
of the used elementary joints are computed from the frame_a and frame_b
coordinates. Still, it is possible to use the components in a
tree structure. In this case states are selected from bodies that are
connected to the frame_a or frame_b side of the component.
In most cases this gives a less efficient solution, as if elementary
joints of package MultiBody.Joints would be used directly.
</p>
<p>
The analytic handling of kinematic loops by using joint aggregations
with 6 degrees of freedom as provided in this package, is a <b>new</b>
methodology. It is based on a more general method for solving
non-linear equations of kinematic loops developed by Woernle and
Hiller. An automatic application of this more general method
is difficult, and a manual application is only suited for
specialists in this field. The method introduced here is a
compromize: It can be quite easily applied by an end user, but
for a smaller class of kinematic loops. The method of the "characteristic
pair of joints" from Woernle and Hiller is described in:
</p>
<dl>
<dt>Woernle C.:</dt
<dd><b>Ein systematisches Verfahren zur Aufstellung der geometrischen
    Schliessbedingungen in kinematischen Schleifen mit Anwendung
    bei der Rueckwaertstransformation fuer Industrieroboter.</b><br>
    Fortschritt-Berichte VDI, Reihe 18, Nr. 59, Duesseldorf: VDI-Verlag 1988,
    ISBN 3-18-145918-6.<br>&nbsp;</dd>
<dt>Hiller M., and Woernle C.:</dt
<dd><b>A Systematic Approach for Solving the Inverse Kinematic
    Problem of Robot Manipulators</b>.<br>
    Proceedings 7th World Congress Th. Mach. Mech., Sevilla 1987. </dd>
</dl>
<pre></PRE><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD><A HREF="MultiBody_Joints_Assemblies.html#MultiBody.Joints.Assemblies.JointUPS"
>JointUPS</A>
</TD><TD>Universal - prismatic - spherical joint aggregation (no constraints, no potential states)</TD></TR>
<TR><TD><A HREF="MultiBody_Joints_Assemblies.html#MultiBody.Joints.Assemblies.JointUSR"
>JointUSR</A>
</TD><TD>Universal - spherical - revolute joint aggregation (no constraints, no potential states)</TD></TR>
<TR><TD><A HREF="MultiBody_Joints_Assemblies.html#MultiBody.Joints.Assemblies.JointUSP"
>JointUSP</A>
</TD><TD>Universal - spherical - prismatic joint aggregation (no constraints, no potential states)</TD></TR>
<TR><TD><A HREF="MultiBody_Joints_Assemblies.html#MultiBody.Joints.Assemblies.JointSSR"
>JointSSR</A>
</TD><TD>Spherical - spherical - revolute joint aggregation with mass (no constraints, no potential states)</TD></TR>
<TR><TD><A HREF="MultiBody_Joints_Assemblies.html#MultiBody.Joints.Assemblies.JointSSP"
>JointSSP</A>
</TD><TD>Spherical - spherical - prismatic joint aggregation with mass (no constraints, no potential states)</TD></TR>
<TR><TD><A HREF="MultiBody_Joints_Assemblies.html#MultiBody.Joints.Assemblies.JointRRR"
>JointRRR</A>
</TD><TD>Planar revolute - revolute - revolute joint aggregation (no constraints, no potential states)</TD></TR>
<TR><TD><A HREF="MultiBody_Joints_Assemblies.html#MultiBody.Joints.Assemblies.JointRRP"
>JointRRP</A>
</TD><TD>Planar revolute - revolute - prismatic joint aggregation (no constraints, no potential states)</TD></TR>
</TABLE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE JointUPS<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><IMG SRC="MultiBody.Joints.Assemblies.JointUPSI.png" ALT="MultiBody.Joints.Assemblies.JointUPS" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="MultiBody.Joints.Assemblies.JointUPS"></A><A HREF="MultiBody_Joints_Assemblies.html#MultiBody.Joints.Assemblies"
>MultiBody.Joints.Assemblies</A>.JointUPS</H2>
<B>Universal - prismatic - spherical joint aggregation (no constraints, no potential states)</B><p>
<IMG SRC="MultiBody.Joints.Assemblies.JointUPSD.png" ALT="MultiBody.Joints.Assemblies.JointUPS">
<H3>Information</H3>
<PRE></pre>
<p>
This component consists of a <b>universal</b> joint at frame_a,
a <b>spherical</b> joint at frame_b and a <b>prismatic</b> joint along the
line connecting the origin of frame_a and the origin of frame_b,
see the default animation in the following figure (the axes vectors
are not part of the default animation):
</p>
<p align="center">
<IMG SRC="../Images/Joints/JointUPS.png" ALT="model Joints.Assemblies.JointUPS">
</p>
<p>
This joint aggregation has no mass and no inertia and
introduces neither constraints nor potential state variables.
It is especially useful to build up more complicated force elements
where the mass and/or inertia of the force element shall be taken
into account.
</p>
<p>
The universal joint is defined in the following way:
<p>
<ul>
<li> The rotation <b>axis</b> of revolute joint <b>1</b> is along parameter
     vector n1_a which is fixed in frame_a.<li>
<li> The rotation <b>axis</b> of revolute joint <b>2</b> is perpendicular to
     axis 1 and to the line connecting the universal and the spherical joint.
</ul>
<p>
The definition of axis 2 of the universal joint is performed according
to the most often occuring case. In a future release, axis 2 might
be explicitly definable via a parameter. However, the treatment is much more
complicated and the number of operations is considerably higher,
if axis 2 is not orthogonal to axis 1 and to the connecting rod.
</p>
<p>
Note, there is a <b>singularity</b> when axis 1 and the connecting line are parallel
to each other. Therefore, if possible n1_a should be selected in such a way that it
is perpendicular to nAxis_ia in the initial configuration (i.e., the
distance to the singularity is as large as possible).
</p>
<p>
An additional <b>frame_ia</b> is present. It is <b>fixed</b> on the line
connecting the universal and the spherical joint at the
origin of <b>frame_a</b>. The placement of frame_ia on this line
is implicitly defined by the universal joint (frame_a and frame_ia coincide
when the angles of the two revolute joints of the universal joint are zero)
and by parameter vector <b>nAxis_ia</b>, an axis vector directed
along the line from the origin of frame_a to the spherical joint,
resolved in frame_<b>ia</b>.
</p
<p>
An additional <b>frame_ib</b> is present. It is <b>fixed</b> in the line
connecting the prismatic and the spherical joint at the
origin of <b>frame_b</b>.
It is always parallel to <b>frame_ia</b>.
</p>
<p>
Note, this joint aggregation can be used in cases where
in reality a rod with spherical joints at each end are present.
Such a system has an additional degree of freedom to rotate
the rod along its axis. In practice this rotation is usually
of no interested and is mathematically removed by replacing one
of the spherical joints by a universal joint.
</p>
<p>
The easiest way to define the parameters of this joint is by moving the
MultiBody system in a <b>reference configuration</b> where <b>all frames</b>
of all components are <b>parallel</b> to each other (alternatively,
at least frame_a, frame_ia and frame_ib of the JointUSP joint
should be parallel to each other when defining an instance of this
component).
</p>
<pre> </PRE>
<H3>Parameters</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>animation</TD><TD>true</TD><TD>= true, if animation shall be enabled</TD></TR>
<TR><TD>showUniversalAxes</TD><TD>true</TD><TD> = true, if universal joint shall be visualized with two cylinders, otherwise with a sphere (provided animation=true)</TD></TR>
<TR><TD>n1_a</TD><TD>{0,0,1}</TD><TD>Axis 1 of universal joint resolved in frame_a (axis 2 is orthogonal to axis 1 and to line from universal to spherical joint)</TD></TR>
<TR><TD>nAxis_ia[3]</TD><TD>{1,0,0}</TD><TD>Axis vector along line from origin of frame_a to origin of frame_b, resolved in frame_ia [m]</TD></TR>
<TR><TD>s_offset</TD><TD>0</TD><TD>Relative distance offset (distance between frame_a and frame_b = s(t) + s_offset) [m]</TD></TR>
<TR><TD>sphereDiameter</TD><TD>world.defaultJointLength</TD><TD> Diameter of spheres representing the spherical joints [m]</TD></TR>
<TR><TD>sphereColor</TD><TD>Types.Defaults.JointColor</TD><TD> Color of spheres representing the spherical joints</TD></TR>
<TR><TD>axisDiameter</TD><TD>sphereDiameter/Types.Defaults.JointRodDiameterFraction</TD><TD> Diameter of cylinder on the connecting line from frame_a to frame_b [m]</TD></TR>
<TR><TD>axisColor</TD><TD>Types.Defaults.SensorColor</TD><TD> Color of cylinder on the connecting line from frame_a to frame_b</TD></TR>
<TR><TD>cylinderLength</TD><TD>world.defaultJointLength</TD><TD> Length of cylinders representing the two universal joint axes [m]</TD></TR>
<TR><TD>cylinderDiameter</TD><TD>world.defaultJointWidth</TD><TD> Diameter of cylinders representing the two universal joint axes [m]</TD></TR>
<TR><TD>cylinderColor</TD><TD>Types.Defaults.JointColor</TD><TD> Color of cylinders representing the two universal joint axes</TD></TR>
<TR><TD>checkTotalPower</TD><TD>false</TD><TD> = true, if total power flowing into this component shall be determined (must be zero)</TD></TR>
</TABLE>
<H3>Modelica definition</H3>
<PRE>
<font color="blue">model</font> JointUPS <font color="darkgreen">
  &quot;Universal - prismatic - spherical joint aggregation (no constraints, no potential states)&quot;</font>

  <font color="darkgreen"></font>
  <font color="blue">import </font>SI = Modelica.SIunits;
  <font color="blue">extends </font><A HREF="MultiBody_Interfaces.html#MultiBody.Interfaces.PartialTwoFrames"
>Interfaces.PartialTwoFrames</A>;
  <A HREF="MultiBody_Interfaces.html#MultiBody.Interfaces.Frame_a"
>MultiBody.Interfaces.Frame_a</A> frame_ia;
  <A HREF="MultiBody_Interfaces.html#MultiBody.Interfaces.Frame_b"
>MultiBody.Interfaces.Frame_b</A> frame_ib;
  <font color="blue">parameter </font>Boolean animation=true <font color="darkgreen">&quot;= true, if animation shall be enabled&quot;</font>;
  <font color="blue">parameter </font>Boolean showUniversalAxes=true <font color="darkgreen">
    &quot; = true, if universal joint shall be visualized with two cylinders, otherwise with a sphere (provided animation=true)&quot;</font>;
  <font color="blue">parameter </font><A HREF="MultiBody_Types.html#MultiBody.Types.Axis"
>MultiBody.Types.Axis</A> n1_a={0,0,1} <font color="darkgreen">
    &quot;Axis 1 of universal joint resolved in frame_a (axis 2 is orthogonal to axis 1 and to line from universal to spherical joint)&quot;</font>;
  <font color="blue">parameter </font>SI.Position nAxis_ia[3]={1,0,0} <font color="darkgreen">
    &quot;Axis vector along line from origin of frame_a to origin of frame_b, resolved in frame_ia&quot;</font>;
  <font color="blue">parameter </font>SI.Position s_offset=0 <font color="darkgreen">
    &quot;Relative distance offset (distance between frame_a and frame_b = s(t) + s_offset)&quot;</font>;
  <font color="blue">parameter </font>SI.Diameter sphereDiameter=world.defaultJointLength <font color="darkgreen">
    &quot;|Animation|if animation = true| Diameter of spheres representing the spherical joints&quot;</font>;
  <font color="blue">parameter </font><A HREF="MultiBody_Types.html#MultiBody.Types.Color"
>MultiBody.Types.Color</A> sphereColor=Types.Defaults.JointColor <font color="darkgreen">
    &quot;|Animation|if animation = true| Color of spheres representing the spherical joints&quot;</font>;
  <font color="blue">parameter </font>SI.Diameter axisDiameter=sphereDiameter/Types.Defaults.
      JointRodDiameterFraction <font color="darkgreen">
    &quot;|Animation|if animation = true| Diameter of cylinder on the connecting line from frame_a to frame_b&quot;</font>;
  <font color="blue">parameter </font><A HREF="MultiBody_Types.html#MultiBody.Types.Color"
>MultiBody.Types.Color</A> axisColor=Types.Defaults.SensorColor <font color="darkgreen">
    &quot;|Animation|if animation = true| Color of cylinder on the connecting line from frame_a to frame_b&quot;</font>;
  <font color="blue">parameter </font>SI.Distance cylinderLength=world.defaultJointLength <font color="darkgreen">
    &quot;|Animation|if animation = true and showUniversalAxes| Length of cylinders representing the two universal joint axes&quot;</font>;
  <font color="blue">parameter </font>SI.Distance cylinderDiameter=world.defaultJointWidth <font color="darkgreen">
    &quot;|Animation|if animation = true and showUniversalAxes| Diameter of cylinders representing the two universal joint axes&quot;</font>;
  <font color="blue">parameter </font><A HREF="MultiBody_Types.html#MultiBody.Types.Color"
>MultiBody.Types.Color</A> cylinderColor=Types.Defaults.JointColor <font color="darkgreen">
    &quot;|Animation|if animation = true and showUniversalAxes| Color of cylinders representing the two universal joint axes&quot;</font>;
  <font color="darkgreen"></font>
  <font color="blue">parameter </font>Boolean checkTotalPower=false <font color="darkgreen">
    &quot;|Advanced|| = true, if total power flowing into this component shall be determined (must be zero)&quot;</font>;
  <font color="blue">final </font><font color="blue">parameter </font>Real eAxis_ia[3]=<font color="red">Frames.normalize</font>(nAxis_ia) <font color="darkgreen">
    &quot;Unit vector from origin of frame_a to origin of frame_b, resolved in frame_ia&quot;</font>;
  <font color="blue">final </font><font color="blue">parameter </font>Real e2_ia[3]=<font color="red">Frames.normalize</font>(<font color="red">cross</font>(n1_a, eAxis_ia)) <font color="darkgreen">
    &quot;Unit vector in direction of second rotation axis of universal joint, resolved in frame_ia&quot;</font>;
  <font color="blue">final </font><font color="blue">parameter </font>Real e3_ia[3]=<font color="red">cross</font>(eAxis_ia, e2_ia) <font color="darkgreen">
    &quot;Unit vector perpendicular to eAxis_ia and e2_ia, resolved in frame_ia&quot;</font>;
  SI.Position s <font color="darkgreen">
    &quot;Relative distance between frame_a and frame_b along axis nAxis = s + s_offset&quot;</font>;
  SI.Force f <font color="darkgreen">&quot;= axis.f (driving force in the axis; = -bearing.f)&quot;</font>;
  <font color="darkgreen"></font>
  <A HREF="MultiBody_Frames.html#MultiBody.Frames.Orientation"
>Frames.Orientation</A> R_rel <font color="darkgreen">
    &quot;Relative orientation object to rotate from frame_a to frame_b&quot;</font>;
  SI.Length axisLength <font color="darkgreen">&quot;Distance between frame_a and frame_b&quot;</font>;
  SI.Power totalPower <font color="darkgreen">
    &quot;Total power flowing into this element, if checkTotalPower=true (otherwise dummy)&quot;</font>;
  <font color="darkgreen"></font>
<font color="blue">protected </font>
  SI.Force f_c_a[3] <font color="darkgreen">&quot;frame_ia.f resolved in frame_a&quot;</font>;
  SI.Torque t_cd_a[3] <font color="darkgreen">&quot;frame_ia.t + frame_ib.t resolved in frame_a&quot;</font>;
  SI.Force f_bd_a[3] <font color="darkgreen">&quot;frame_b.f + frame_ib.f resolved in frame_a&quot;</font>;
  SI.Position rAxis_0[3] <font color="darkgreen">
    &quot;Position vector from origin of frame_a to origin of frame_b resolved in world frame&quot;</font>;
  SI.Position rAxis_a[3] <font color="darkgreen">
    &quot;Position vector from origin of frame_a to origin of frame_b resolved in frame_a&quot;</font>;
  Real eAxis_a[3] <font color="darkgreen">&quot;Unit vector in direction of rAxis_a, resolved in frame_a&quot;</font>;
  Real e2_a[3] <font color="darkgreen">
    &quot;Unit vector in direction of second rotation axis of universal joint, resolved in frame_a&quot;</font>;
  Real e3_a[3] <font color="darkgreen">
    &quot;Unit vector perpendicular to eAxis_a and e2_a, resolved in frame_a&quot;</font>;
  Real n2_a[3] <font color="darkgreen">
    &quot;Vector in direction of second rotation axis of universal joint, resolved in frame_a&quot;</font>;
  Real length2_n2_a(unit=&quot;m2&quot;) <font color="darkgreen">&quot;Square of length of vector n2_a&quot;</font>;
  <A HREF="MultiBody_Frames.html#MultiBody.Frames.Orientation"
>Frames.Orientation</A> R_ia_a <font color="darkgreen">&quot;Rotation from frame_a to frame_ia&quot;</font>;
  <A HREF="MultiBody_Frames.html#MultiBody.Frames.Orientation"
>Frames.Orientation</A> R_ib_b <font color="darkgreen">&quot;Rotation from frame_b to frame_ib&quot;</font>;
  Real T_ia_a[3, 3] <font color="darkgreen">&quot;Transformation matrix from frame_a to frame_ia&quot;</font>;
  <font color="darkgreen"></font>
  <font color="blue">parameter </font>Integer ndim=<font color="blue">if </font>world.enableAnimation<font color="blue"> and </font>animation<font color="blue"> then </font>1<font color="blue"> else </font>0;
  <font color="blue">parameter </font>Integer ndim1=<font color="blue">if </font>world.enableAnimation<font color="blue"> and </font>animation<font color="blue"> and </font><font color="blue">not </font>
      showUniversalAxes<font color="blue"> then </font>1<font color="blue"> else </font>0;
  <font color="blue">parameter </font>Integer ndim2=<font color="blue">if </font>world.enableAnimation<font color="blue"> and </font>animation<font color="blue"> and </font>
      showUniversalAxes<font color="blue"> then </font>1<font color="blue"> else </font>0;
  <A HREF="MultiBody_Visualizers_Advanced.html#MultiBody.Visualizers.Advanced.Shape"
>Visualizers.Advanced.Shape</A> axisCylinder[ndim](
    <font color="blue">each </font>shapeType=&quot;cylinder&quot;,
    <font color="blue">each </font>color=axisColor,
    <font color="blue">each </font>length=axisLength,
    <font color="blue">each </font>width=axisDiameter,
    <font color="blue">each </font>height=axisDiameter,
    <font color="blue">each </font>lengthDirection=eAxis_ia,
    <font color="blue">each </font>widthDirection=e2_ia,
    <font color="blue">each </font>r=frame_ia.r_0,
    <font color="blue">each </font>R=frame_ia.R);
  <A HREF="MultiBody_Visualizers_Advanced.html#MultiBody.Visualizers.Advanced.Shape"
>Visualizers.Advanced.Shape</A> sphericalShape_b[ndim](
    <font color="blue">each </font>shapeType=&quot;sphere&quot;,
    <font color="blue">each </font>color=sphereColor,
    <font color="blue">each </font>length=sphereDiameter,
    <font color="blue">each </font>width=sphereDiameter,
    <font color="blue">each </font>height=sphereDiameter,
    <font color="blue">each </font>lengthDirection={1,0,0},
    <font color="blue">each </font>widthDirection={0,1,0},
    <font color="blue">each </font>r_shape={-0.5,0,0}*sphereDiameter,
    <font color="blue">each </font>r=frame_b.r_0,
    <font color="blue">each </font>R=frame_b.R);
  <A HREF="MultiBody_Visualizers_Advanced.html#MultiBody.Visualizers.Advanced.Shape"
>Visualizers.Advanced.Shape</A> sphericalShape_a[ndim1](
    <font color="blue">each </font>shapeType=&quot;sphere&quot;,
    <font color="blue">each </font>color=sphereColor,
    <font color="blue">each </font>length=sphereDiameter,
    <font color="blue">each </font>width=sphereDiameter,
    <font color="blue">each </font>height=sphereDiameter,
    <font color="blue">each </font>lengthDirection={1,0,0},
    <font color="blue">each </font>widthDirection={0,1,0},
    <font color="blue">each </font>r_shape={-0.5,0,0}*sphereDiameter,
    <font color="blue">each </font>r=frame_a.r_0,
    <font color="blue">each </font>R=frame_a.R);
  <A HREF="MultiBody_Visualizers_Advanced.html#MultiBody.Visualizers.Advanced.Shape"
>Visualizers.Advanced.Shape</A> universalShape1[ndim2](
    <font color="blue">each </font>shapeType=&quot;cylinder&quot;,
    <font color="blue">each </font>color=cylinderColor,
    <font color="blue">each </font>length=cylinderLength,
    <font color="blue">each </font>width=cylinderDiameter,
    <font color="blue">each </font>height=cylinderDiameter,
    <font color="blue">each </font>lengthDirection=n1_a,
    <font color="blue">each </font>widthDirection={0,1,0},
    <font color="blue">each </font>r_shape=-n1_a*(cylinderLength/2),
    <font color="blue">each </font>r=frame_a.r_0,
    <font color="blue">each </font>R=frame_a.R);
  <A HREF="MultiBody_Visualizers_Advanced.html#MultiBody.Visualizers.Advanced.Shape"
>Visualizers.Advanced.Shape</A> universalShape2[ndim2](
    <font color="blue">each </font>shapeType=&quot;cylinder&quot;,
    <font color="blue">each </font>color=cylinderColor,
    <font color="blue">each </font>length=cylinderLength,
    <font color="blue">each </font>width=cylinderDiameter,
    <font color="blue">each </font>height=cylinderDiameter,
    <font color="blue">each </font>lengthDirection=e2_ia,
    <font color="blue">each </font>widthDirection={0,1,0},
    <font color="blue">each </font>r_shape=-e2_ia*(cylinderLength/2),
    <font color="blue">each </font>r=frame_ia.r_0,
    <font color="blue">each </font>R=frame_ia.R);
<font color="blue">public </font>
  Modelica.Mechanics.Translational.Interfaces.Flange_b bearing;
  Modelica.Mechanics.Translational.Interfaces.Flange_a axis;
<font color="blue">equation </font>
  <font color="red">defineBranch</font>(frame_a.R, frame_ia.R);
  <font color="red">defineBranch</font>(frame_ia.R, frame_ib.R);
  <font color="darkgreen"></font>
  <font color="darkgreen">// Translational flanges</font>
  axisLength = s + s_offset;
  bearing.s = 0;
  axis.s = s;
  axis.f = f;
  <font color="darkgreen"></font>
  <font color="darkgreen">// Position vector rAxis from frame_a to frame_b</font>
  rAxis_0 = frame_b.r_0 - frame_a.r_0;
  rAxis_a = <font color="red">Frames.resolve2</font>(frame_a.R, rAxis_0);
  <font color="darkgreen"></font>
  <font color="darkgreen">/* Determine relative Rotation R_rel_c from frame_a to frame_ia
     and absolute rotation of frame_a.R.
  */</font>
  axisLength = <font color="red">sqrt</font>(rAxis_0*rAxis_0);
  <font color="red">assert</font>(axisLength &gt; 1.0e-15, &quot;
Distance between frame_a and frame_b of a JointUPS joint
became zero. This is not allowed. If this occurs during
initialization, the initial conditions are probably wrong.&quot;);
  <font color="darkgreen"></font>
  eAxis_a = rAxis_a/axisLength;
  n2_a = <font color="red">cross</font>(n1_a, eAxis_a);
  length2_n2_a = n2_a*n2_a;
  <font color="red">assert</font>(<font color="red">noEvent</font>(length2_n2_a &gt; 1.e-10), &quot;
A MultiBody.Joints.Assemblies.JointUPS joint (consisting of
a universal, prismatic and spherical joint) is in the singular
configuration of the universal joint. This means that axis 1 of
the universal joint defined via parameter \&quot;n1_a\&quot; is parallel to vector
\&quot;eAxis_ia\&quot; that is directed from the origin of frame_a to the
origin of frame_b. You may try to use another \&quot;n1_a\&quot; vector.
&quot;);
  e2_a = n2_a/<font color="red">sqrt</font>(length2_n2_a);
  e3_a = <font color="red">cross</font>(eAxis_a, e2_a);
  T_ia_a = [eAxis_ia, e2_ia, e3_ia]*<font color="red">transpose</font>([eAxis_a, e2_a, e3_a]);
  R_ia_a = <font color="red">Frames.from_T</font>(T_ia_a);
  <font color="darkgreen"></font>
  <font color="darkgreen">// Compute kinematic quantities of frame_ia and frame_ib</font>
  frame_ia.r_0 = frame_a.r_0;
  frame_ib.r_0 = frame_b.r_0;
  frame_ia.R = <font color="red">Frames.absoluteRotation</font>(frame_a.R, R_ia_a);
  frame_ib.R = frame_ia.R;
  R_ib_b = <font color="red">Frames.relativeRotation</font>(frame_b.R, frame_ib.R);
  <font color="darkgreen"></font>
  <font color="darkgreen">/* In the following formulas f_a, f_b, f_ia, f_ib, t_a, t_b, t_ia, t_ib are
     the forces and torques at frame_a, frame_b, frame_ia, frame_ib respectively,
     resolved in frame_a. eAxis, e2, e3 are the unit vectors resolved in frame_a.
     Torque balance at the rod around the origin of frame_a:
       0 = t_a + t_ia + t_ib + cross(rAxis, (f_b+f_ib))
     with
         rAxis = axisLength*eAxis
         f_bd  = f_b + f_ib
         f_bd  = f*eAxis + f_bd[2]*e2 + f_bd[3]*e3
     follows:
         0 = t_a + t_ia + axisLength*(f_bd[2]*e_z - f_bd[3]*e_y)
     The projection of t_a with respect to universal joint axes vanishes:
       e1*t_a = 0
       e2*t_a = 0
     Therefore:
        0 = e1*(t_ia + t_ib) + axisLength*f_bd[2]*(e1*e3)
        0 = e2*(t_ia + t_ib) - axisLength*f_bd[3]
     or
        f_bd = f*eAxis - e2*(e1*(t_ia+t_ib))/(axisLength*(e1*e3)) +
                e3*(e2*(t_ia+t_ib))/axisLength
     Force balance:
        0 = f_a + f_bd + f_ia
  */</font>
  R_rel = <font color="red">Frames.relativeRotation</font>(frame_a.R, frame_b.R);
  [f_c_a, t_cd_a] = <font color="red">Frames.multipleResolve1</font>(R_ia_a, [frame_ia.f, frame_ia.t +
    frame_ib.t]);
  f_bd_a = -eAxis_a*f - e2_a*((n1_a*t_cd_a)/(axisLength*(n1_a*e3_a))) + e3_a*((
    e2_a*t_cd_a)/axisLength);
  <font color="red">zeros</font>(3) = frame_b.f + <font color="red">Frames.resolve1</font>(R_ib_b, frame_ib.f) - <font color="red">Frames.resolve2</font>(
    R_rel, f_bd_a);
  <font color="red">zeros</font>(3) = frame_b.t;
  <font color="red">zeros</font>(3) = frame_a.f + f_c_a + f_bd_a;
  <font color="red">zeros</font>(3) = frame_a.t + t_cd_a + <font color="red">cross</font>(rAxis_a, f_bd_a);
  <font color="darkgreen"></font>
  <font color="darkgreen">// Measure power for test purposes</font>
  <font color="blue">if </font>checkTotalPower<font color="blue"> then</font>
    totalPower = frame_a.f*<font color="red">Frames.resolve2</font>(frame_a.R, <font color="red">der</font>(frame_a.r_0)) +
      frame_b.f*<font color="red">Frames.resolve2</font>(frame_b.R, <font color="red">der</font>(frame_b.r_0)) + frame_ia.f*<font color="red">
      Frames.resolve2</font>(frame_ia.R, <font color="red">der</font>(frame_ia.r_0)) + frame_ib.f*<font color="red">
      Frames.resolve2</font>(frame_ib.R, <font color="red">der</font>(frame_ib.r_0)) + frame_a.t*<font color="red">
      Frames.angularVelocity2</font>(frame_a.R, <font color="red">der</font>(frame_a.R)) + frame_b.t*<font color="red">
      Frames.angularVelocity2</font>(frame_b.R, <font color="red">der</font>(frame_b.R)) + frame_ia.t*<font color="red">
      Frames.angularVelocity2</font>(frame_ia.R, <font color="red">der</font>(frame_ia.R)) + frame_ib.t*<font color="red">
      Frames.angularVelocity2</font>(frame_ib.R, <font color="red">der</font>(frame_ib.R)) + axis.f*<font color="red">der</font>(axis.s)
       + bearing.f*<font color="red">der</font>(bearing.s);
  <font color="blue">else</font>
    totalPower = 0;
  <font color="blue">end if</font>;
<font color="blue">end </font>JointUPS;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE JointSSP<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><IMG SRC="MultiBody.Joints.Assemblies.JointSSPI.png" ALT="MultiBody.Joints.Assemblies.JointSSP" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="MultiBody.Joints.Assemblies.JointSSP"></A><A HREF="MultiBody_Joints_Assemblies.html#MultiBody.Joints.Assemblies"
>MultiBody.Joints.Assemblies</A>.JointSSP</H2>
<B>Spherical - spherical - prismatic joint aggregation with mass (no constraints, no potential states)</B><p>
<IMG SRC="MultiBody.Joints.Assemblies.JointSSPD.png" ALT="MultiBody.Joints.Assemblies.JointSSP">
<H3>Information</H3>
<PRE></pre>
<p>
This component consists of a <b>spherical</b> joint 1 at frame_a, a <b>prismatic</b>
joint at frame_b and a <b>spherical</b> joint 2 which is connected via rod 1
to the spherical joint 1 and via rod 2 to the prismatic joint, see the default
animation in the following figure (the axes vectors are not part of the
default animation):
</p>
<p align="center">
<IMG SRC="../Images/Joints/JointSSP.png" ALT="model Joints.Assemblies.JointSSP">
</p>
<p>
Besides an optional point mass in the middle of rod 1,
this joint aggregation has no mass and no inertia,
and introduces neither constraints nor potential state variables.
It should be used in kinematic loops whenever possible since
the non-linear system of equations introduced by this joint aggregation
is solved <b>analytically</b> (i.e., a solution is always computed, if a
unique solution exists).
</p>
<p>
An additional <b>frame_ib</b> is present. It is <b>fixed</b> in rod 2
connecting the prismatic and the spherical joint at the side of the prismatic
joint that is connected to this rod (= rod2.frame_a = prismatic.frame_a).
</p>
<p>
An additional <b>frame_im</b> is present. It is <b>fixed</b> in rod 2
connecting the prismatic and the spherical joint at the side of spherical
joint 2 that is connected to this rod (= rod2.frame_b).
It is always parallel to <b>frame_ib</b>.
</p>
<p>
The easiest way to define the parameters of this joint is by moving the
MultiBody system in a <b>reference configuration</b> where <b>all frames</b>
of all components are <b>parallel</b> to each other (alternatively,
at least frame_b and frame_ib of the JointSSP joint
should be parallel to each other when defining an instance of this
component).
</p>
<pre> </PRE>
<H3>Parameters</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>animation</TD><TD>true</TD><TD>= true, if animation shall be enabled</TD></TR>
<TR><TD>showMass</TD><TD>true</TD><TD>= true, if point mass on rod 1 shall be shown (provided animation = true and rod1Mass &gt; 0)</TD></TR>
<TR><TD>rod1Length</TD><TD>1</TD><TD>Distance between the origins of the two spherical joints  [m]</TD></TR>
<TR><TD>rod1Mass</TD><TD>0</TD><TD>Mass of rod 1 (= point mass located in middle of rod connecting the two spherical joints) [kg]</TD></TR>
<TR><TD>n_b</TD><TD>{0,0,1}</TD><TD>Axis of prismatic joint fixed and resolved in frame_b</TD></TR>
<TR><TD>rRod2_ib[3]</TD><TD>{1,0,0}</TD><TD>Vector from origin of frame_ib to spherical joint in the middle, resolved in frame_ib [m]</TD></TR>
<TR><TD>s_offset</TD><TD>0</TD><TD>Relative distance offset of prismatic joint (distance between frame_b and frame_ib = s(t) + s_offset) [m]</TD></TR>
<TR><TD>s_guess</TD><TD>0</TD><TD>Select the configuration such that at initial time |s(t0)-s_guess| is minimal [m]</TD></TR>
<TR><TD>sphereDiameter</TD><TD>world.defaultJointLength</TD><TD> Diameter of the spheres representing the two spherical joints [m]</TD></TR>
<TR><TD>sphereColor</TD><TD>MultiBody.Types.Defaults.JointColor</TD><TD> Color of the spheres representing the two spherical joints</TD></TR>
<TR><TD>rod1Diameter</TD><TD>sphereDiameter/Types.Defaults.JointRodDiameterFraction</TD><TD> Diameter of rod 1 connecting the two spherical joints [m]</TD></TR>
<TR><TD>rod1Color</TD><TD>MultiBody.Types.Defaults.RodColor</TD><TD> Color of rod 1 connecting the two spherical joint</TD></TR>
<TR><TD>rod2Diameter</TD><TD>rod1Diameter</TD><TD> Diameter of rod 2 connecting the revolute joint and spherical joint 2 [m]</TD></TR>
<TR><TD>rod2Color</TD><TD>rod1Color</TD><TD> Color of rod 2 connecting the revolute joint and spherical joint 2</TD></TR>
<TR><TD>boxWidthDirection</TD><TD>{0,1,0}</TD><TD> Vector in width direction of prismatic joint box, resolved in frame_b</TD></TR>
<TR><TD>boxWidth</TD><TD>world.defaultJointWidth</TD><TD> Width of prismatic joint box [m]</TD></TR>
<TR><TD>boxHeight</TD><TD>boxWidth</TD><TD> Height of prismatic joint box [m]</TD></TR>
<TR><TD>boxColor</TD><TD>Types.Defaults.JointColor</TD><TD> Color of prismatic joint box</TD></TR>
<TR><TD>checkTotalPower</TD><TD>false</TD><TD> = true, if total power flowing into this component shall be determined (must be zero)</TD></TR>
</TABLE>
<H3>Modelica definition</H3>
<PRE>
<font color="blue">model</font> JointSSP <font color="darkgreen">
  &quot;Spherical - spherical - prismatic joint aggregation with mass (no constraints, no potential states)&quot;</font>

  <font color="darkgreen"></font>
  <font color="blue">import </font>SI = Modelica.SIunits;
  <font color="blue">import </font>Cv = Modelica.SIunits.Conversions;
  <font color="darkgreen"></font>
  <font color="blue">extends </font><A HREF="MultiBody_Interfaces.html#MultiBody.Interfaces.PartialTwoFrames"
>MultiBody.Interfaces.PartialTwoFrames</A>;
  <A HREF="MultiBody_Interfaces.html#MultiBody.Interfaces.Frame_b"
>MultiBody.Interfaces.Frame_b</A> frame_ib;
  <A HREF="MultiBody_Interfaces.html#MultiBody.Interfaces.Frame_b"
>MultiBody.Interfaces.Frame_b</A> frame_im;
  Modelica.Mechanics.Translational.Interfaces.Flange_a axis;
  Modelica.Mechanics.Translational.Interfaces.Flange_b bearing;
  <font color="darkgreen"></font>
  <font color="blue">parameter </font>Boolean animation=true <font color="darkgreen">&quot;= true, if animation shall be enabled&quot;</font>;
  <font color="blue">parameter </font>Boolean showMass=true <font color="darkgreen">
    &quot;= true, if point mass on rod 1 shall be shown (provided animation = true and rod1Mass &gt; 0)&quot;</font>;
  <font color="blue">parameter </font>SI.Length rod1Length(min=Modelica.Constants.eps) = 1 <font color="darkgreen">
    &quot;Distance between the origins of the two spherical joints &quot;</font>;
  <font color="blue">parameter </font>SI.Mass rod1Mass=0 <font color="darkgreen">
    &quot;Mass of rod 1 (= point mass located in middle of rod connecting the two spherical joints)&quot;</font>;
  <font color="blue">parameter </font><A HREF="MultiBody_Types.html#MultiBody.Types.Axis"
>MultiBody.Types.Axis</A> n_b={0,0,1} <font color="darkgreen">
    &quot;Axis of prismatic joint fixed and resolved in frame_b&quot;</font>;
  <font color="blue">parameter </font>SI.Position rRod2_ib[3]={1,0,0} <font color="darkgreen">
    &quot;Vector from origin of frame_ib to spherical joint in the middle, resolved in frame_ib&quot;</font>;
  <font color="blue">parameter </font>SI.Position s_offset=0 <font color="darkgreen">
    &quot;Relative distance offset of prismatic joint (distance between frame_b and frame_ib = s(t) + s_offset)&quot;</font>;
  <font color="blue">parameter </font>SI.Position s_guess=0 <font color="darkgreen">
    &quot;Select the configuration such that at initial time |s(t0)-s_guess| is minimal&quot;</font>;
  <font color="darkgreen"></font>
  <font color="blue">parameter </font>SI.Diameter sphereDiameter=world.defaultJointLength <font color="darkgreen">
    &quot;|Animation|if animation = true| Diameter of the spheres representing the two spherical joints&quot;</font>;
  <font color="blue">parameter </font><A HREF="MultiBody_Types.html#MultiBody.Types.Color"
>MultiBody.Types.Color</A> sphereColor=MultiBody.Types.Defaults.JointColor <font color="darkgreen">
    &quot;|Animation|if animation = true| Color of the spheres representing the two spherical joints&quot;</font>;
  <font color="blue">parameter </font>SI.Diameter rod1Diameter=sphereDiameter/Types.Defaults.
      JointRodDiameterFraction <font color="darkgreen">
    &quot;|Animation|if animation = true| Diameter of rod 1 connecting the two spherical joints&quot;</font>;
  <font color="blue">parameter </font><A HREF="MultiBody_Types.html#MultiBody.Types.Color"
>MultiBody.Types.Color</A> rod1Color=MultiBody.Types.Defaults.RodColor <font color="darkgreen">
    &quot;|Animation|if animation = true| Color of rod 1 connecting the two spherical joint&quot;</font>;
  <font color="blue">parameter </font>SI.Diameter rod2Diameter=rod1Diameter <font color="darkgreen">
    &quot;|Animation|if animation = true| Diameter of rod 2 connecting the revolute joint and spherical joint 2&quot;</font>;
  <font color="blue">parameter </font><A HREF="MultiBody_Types.html#MultiBody.Types.Color"
>MultiBody.Types.Color</A> rod2Color=rod1Color <font color="darkgreen">
    &quot;|Animation|if animation = true| Color of rod 2 connecting the revolute joint and spherical joint 2&quot;</font>;
  <font color="darkgreen"></font>
  <font color="blue">parameter </font><A HREF="MultiBody_Types.html#MultiBody.Types.Axis"
>MultiBody.Types.Axis</A> boxWidthDirection={0,1,0} <font color="darkgreen">
    &quot;|Animation|if animation = true| Vector in width direction of prismatic joint box, resolved in frame_b&quot;</font>;
  <font color="blue">parameter </font>SI.Distance boxWidth=world.defaultJointWidth <font color="darkgreen">
    &quot;|Animation|if animation = true| Width of prismatic joint box&quot;</font>;
  <font color="blue">parameter </font>SI.Distance boxHeight=boxWidth <font color="darkgreen">
    &quot;|Animation|if animation = true| Height of prismatic joint box&quot;</font>;
  <font color="blue">parameter </font><A HREF="MultiBody_Types.html#MultiBody.Types.Color"
>MultiBody.Types.Color</A> boxColor=Types.Defaults.JointColor <font color="darkgreen">
    &quot;|Animation|if animation = true| Color of prismatic joint box&quot;</font>;
  <font color="blue">parameter </font>Boolean checkTotalPower=false <font color="darkgreen">
    &quot;|Advanced|| = true, if total power flowing into this component shall be determined (must be zero)&quot;</font>;
  SI.Position aux <font color="darkgreen">
    &quot;Denominator used to compute force in rod connecting universal and spherical joint&quot;</font>;
  SI.Power totalPower <font color="darkgreen">
    &quot;Total power flowing into this element, if checkTotalPower=true (otherwise dummy)&quot;</font>;
  <font color="darkgreen"></font>
  <A HREF="MultiBody_Joints_Internal.html#MultiBody.Joints.Internal.PrismaticWithLengthConstraint"
>MultiBody.Joints.Internal.PrismaticWithLengthConstraint</A> prismatic(
    animation=animation,
    length=rod1Length,
    n=n_b,
    s_offset=s_offset,
    s_guess=s_guess,
    axisForceBalance=false,
    boxWidthDirection=boxWidthDirection,
    boxWidth=boxWidth,
    boxHeight=boxHeight,
    boxColor=boxColor);
  <A HREF="MultiBody_Joints.html#MultiBody.Joints.SphericalSpherical"
>MultiBody.Joints.SphericalSpherical</A> rod1(
    animation=animation,
    showMass=showMass,
    m=rod1Mass,
    rodLength=rod1Length,
    rodDiameter=rod1Diameter,
    sphereDiameter=sphereDiameter,
    rodColor=rod1Color,
    kinematicConstraint=false,
    sphereColor=sphereColor);
  <A HREF="MultiBody_Parts.html#MultiBody.Parts.FixedTranslation"
>MultiBody.Parts.FixedTranslation</A> rod2(
    animation=animation,
    width=rod2Diameter,
    height=rod2Diameter,
    color=rod2Color,
    r=rRod2_ib);
  <A HREF="MultiBody_Sensors.html#MultiBody.Sensors.RelativeSensor"
>MultiBody.Sensors.RelativeSensor</A> relativeSensor(animation=false);
  Modelica.Blocks.Sources.Constant position_b(k=rRod2_ib);
<font color="blue">equation </font>
  <font color="red">defineRoot</font>(frame_ib.R);
  <font color="darkgreen">/* Compute the unknown force in the rod of the rod1 joint
     by a force balance:
       0 = frame_b.f + frame_ib.f + frame_im.f +
           Frames.resolve2(rod1.R_rel, rod1.f_rod*rod1.eRod_a)
     The condition is that the projection of the force in the prismatic
     joint along the axis of the prismatic joint is equal to the driving
     axis force in the flange:
       -prismatic.f = prismatic.e*frame_b.f
     Therefore, we have with e=prismatic.e and f=prismatic.f
        f = e*(frame_ib.f + frame_im.f +
               Frames.resolve2(rod1.R_rel, rod1.f_rod*rod1.eRod_a))
          = e*(frame_ib.f + frame_im.f +
               rod1.f_rod*Frames.resolve2(rod1.R_rel, rod1.eRod_a))
     Solving this equation for f_rod results in
       rod1.f_rod = (f - e*(frame_ib.f + frame_im.f))
                    / (e*Frames.resolve2(rod1.R_rel, rod1.eRod_a))
     Additionally, a guard against division by zero is introduced
  */</font>
  aux = prismatic.e*<font color="red">Frames.resolve2</font>(rod1.R_rel, rod1.eRod_a);
  rod1.f_rod = (-prismatic.f - prismatic.e*(frame_ib.f + frame_im.f))/<font color="red">noEvent</font>(<font color="blue">
    if </font><font color="red">abs</font>(aux) &lt; 1.e-10<font color="blue"> then </font>1.e-10<font color="blue"> else </font>aux);
  <font color="darkgreen"></font>
  <font color="darkgreen">// Measure power for test purposes</font>
  <font color="blue">if </font>checkTotalPower<font color="blue"> then</font>
    totalPower = frame_a.f*<font color="red">Frames.resolve2</font>(frame_a.R, <font color="red">der</font>(frame_a.r_0)) +
      frame_b.f*<font color="red">Frames.resolve2</font>(frame_b.R, <font color="red">der</font>(frame_b.r_0)) + frame_ib.f*<font color="red">
      Frames.resolve2</font>(frame_ib.R, <font color="red">der</font>(frame_ib.r_0)) + frame_im.f*<font color="red">
      Frames.resolve2</font>(frame_im.R, <font color="red">der</font>(frame_im.r_0)) + frame_a.t*<font color="red">
      Frames.angularVelocity2</font>(frame_a.R, <font color="red">der</font>(frame_a.R)) + frame_b.t*<font color="red">
      Frames.angularVelocity2</font>(frame_b.R, <font color="red">der</font>(frame_b.R)) + frame_ib.t*<font color="red">
      Frames.angularVelocity2</font>(frame_ib.R, <font color="red">der</font>(frame_ib.R)) + frame_im.t*<font color="red">
      Frames.angularVelocity2</font>(frame_im.R, <font color="red">der</font>(frame_im.R)) + axis.f*<font color="red">der</font>(axis.s)
       + bearing.f*<font color="red">der</font>(bearing.s) + (-rod1Mass)*(<font color="red">der</font>(rod1.v_CM_0) - <font color="red">
      world.gravityAcceleration</font>(rod1.r_CM_0))*rod1.v_CM_0;
  <font color="blue">else</font>
    totalPower = 0;
  <font color="blue">end if</font>;
  <font color="darkgreen"></font>
  <font color="red">connect</font>(prismatic.frame_b, rod2.frame_a);
  <font color="red">connect</font>(rod2.frame_b, rod1.frame_b);
  <font color="red">connect</font>(prismatic.frame_a, frame_b);
  <font color="red">connect</font>(rod2.frame_a, frame_ib);
  <font color="red">connect</font>(rod1.frame_a, frame_a);
  <font color="red">connect</font>(relativeSensor.frame_b, frame_a);
  <font color="red">connect</font>(relativeSensor.frame_a, frame_b);
  <font color="red">connect</font>(relativeSensor.outPort, prismatic.position_a);
  <font color="red">connect</font>(position_b.outPort, prismatic.position_b);
  <font color="red">connect</font>(prismatic.axis, axis);
  <font color="red">connect</font>(prismatic.bearing, bearing);
  <font color="red">connect</font>(rod2.frame_b, frame_im);
<font color="blue">end </font>JointSSP;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE JointRRR<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><IMG SRC="MultiBody.Joints.Assemblies.JointRRRI.png" ALT="MultiBody.Joints.Assemblies.JointRRR" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="MultiBody.Joints.Assemblies.JointRRR"></A><A HREF="MultiBody_Joints_Assemblies.html#MultiBody.Joints.Assemblies"
>MultiBody.Joints.Assemblies</A>.JointRRR</H2>
<B>Planar revolute - revolute - revolute joint aggregation (no constraints, no potential states)</B><p>
<IMG SRC="MultiBody.Joints.Assemblies.JointRRRD.png" ALT="MultiBody.Joints.Assemblies.JointRRR">
<H3>Information</H3>
<PRE></pre>
<p>
This component consists of <b>3 revolute</b> joints with parallel
axes of rotation that are connected together by two rods, see the default
animation in the following figure (the axes vectors are not part of the
default animation):
</p>
<p align="center">
<IMG SRC="../Images/Joints/JointRRR.png" ALT="model Joints.Assemblies.JointRRR">
</p>
<p>
This joint aggregation introduces neither constraints nor state variables and
should therefore be used in kinematic loops whenever possible to
avoid non-linear systems of equations. It is only meaningful to
use this component in <b>planar loops</b>. Basically, the position
and orientation of the 3 revolute joints as well as of frame_ia, frame_ib, and
frame_im are calculated by solving analytically a non-linear equation,
given the position and orientation at frame_a and at frame_b.
</p>
<p>
Connector <b>frame_a</b> is the "left" side of the first revolute joint
whereas <b>frame_ia</b> is the "right side of this revolute joint, fixed in rod 1.
Connector <b>frame_b</b> is the "right" side of the third revolute joint
whereas <b>frame_ib</b> is the "left" side of this revolute joint, fixed in rod 2.
Finally, connector <b>frame_im</b> is the connector at the "right" side
of the revolute joint in the middle, fixed in rod 2.
</p>
<p>
The easiest way to define the parameters of this joint is by moving the
MultiBody system in a <b>reference configuration</b> where <b>all frames</b>
of all components are <b>parallel</b> to each other (alternatively,
at least frame_a, frame_ia, frame_im, frame_ib, frame_b of the JointRRR joint
should be parallel to each other when defining an instance of this
component).
</p>
<p>
Basically, the JointRRR model consists internally of a universal -
spherical - revolute joint aggregation (= JointUSR). In a planar
loop this will behave as if 3 revolute joints with parallel axes
are connected by rigid rods.
</p>
<pre> </PRE>
<H3>Parameters</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>animation</TD><TD>true</TD><TD>= true, if animation shall be enabled</TD></TR>
<TR><TD>n_a</TD><TD>{0,0,1}</TD><TD>Axes of revolute joints resolved in frame_a (all axes are parallel to each other)</TD></TR>
<TR><TD>rRod1_ia[3]</TD><TD>{1,0,0}</TD><TD>Vector from origin of frame_a to revolute joint in the middle, resolved in frame_ia [m]</TD></TR>
<TR><TD>rRod2_ib[3]</TD><TD>{-1,0,0}</TD><TD>Vector from origin of frame_ib to revolute joint in the middle, resolved in frame_ib [m]</TD></TR>
<TR><TD>phi_offset</TD><TD>0</TD><TD>Relative angle offset of revolute joint at frame_b (angle = phi(t) + from_deg(phi_offset)) [deg]</TD></TR>
<TR><TD>phi_guess</TD><TD>0</TD><TD>Select the configuration such that at initial time |phi(t0) - from_deg(phi_guess)| is minimal [deg]</TD></TR>
<TR><TD>cylinderLength</TD><TD>world.defaultJointLength</TD><TD> Length of cylinders representing the revolute joints [m]</TD></TR>
<TR><TD>cylinderDiameter</TD><TD>world.defaultJointWidth</TD><TD> Diameter of cylinders representing the revolute joints [m]</TD></TR>
<TR><TD>cylinderColor</TD><TD>MultiBody.Types.Defaults.JointColor</TD><TD> Color of cylinders representing the revolute joints</TD></TR>
<TR><TD>rodDiameter</TD><TD>1.1*cylinderDiameter</TD><TD> Diameter of the two rods connecting the revolute joints [m]</TD></TR>
<TR><TD>rodColor</TD><TD>MultiBody.Types.Defaults.RodColor</TD><TD> Color of the two rods connecting the revolute joint</TD></TR>
<TR><TD>checkTotalPower</TD><TD>false</TD><TD> = true, if total power flowing into this component shall be determined (must be zero)</TD></TR>
</TABLE>
<H3>Modelica definition</H3>
<PRE>
<font color="blue">model</font> JointRRR <font color="darkgreen">
  &quot;Planar revolute - revolute - revolute joint aggregation (no constraints, no potential states)&quot;</font>

  <font color="darkgreen"></font>
  <font color="blue">import </font>SI = Modelica.SIunits;
  <font color="blue">import </font>Cv = Modelica.SIunits.Conversions;
  <font color="darkgreen"></font>
  <font color="blue">extends </font><A HREF="MultiBody_Interfaces.html#MultiBody.Interfaces.PartialTwoFrames"
>MultiBody.Interfaces.PartialTwoFrames</A>;
  <font color="darkgreen"></font>
  <A HREF="MultiBody_Interfaces.html#MultiBody.Interfaces.Frame_a"
>MultiBody.Interfaces.Frame_a</A> frame_ia;
  <A HREF="MultiBody_Interfaces.html#MultiBody.Interfaces.Frame_b"
>MultiBody.Interfaces.Frame_b</A> frame_im;
  <A HREF="MultiBody_Interfaces.html#MultiBody.Interfaces.Frame_b"
>MultiBody.Interfaces.Frame_b</A> frame_ib;
  Modelica.Mechanics.Rotational.Interfaces.Flange_a axis;
  Modelica.Mechanics.Rotational.Interfaces.Flange_b bearing;
  <font color="darkgreen"></font>
  <font color="blue">parameter </font>Boolean animation=true <font color="darkgreen">&quot;= true, if animation shall be enabled&quot;</font>;
  <font color="blue">parameter </font><A HREF="MultiBody_Types.html#MultiBody.Types.Axis"
>MultiBody.Types.Axis</A> n_a={0,0,1} <font color="darkgreen">
    &quot;Axes of revolute joints resolved in frame_a (all axes are parallel to each other)&quot;</font>;
  <font color="blue">final </font><font color="blue">parameter </font>Real n_b[3](fixed=false) = {0,0,1} <font color="darkgreen">
    &quot;Axis of revolute joint fixed and resolved in frame_b&quot;</font>;
  <font color="blue">parameter </font>SI.Position rRod1_ia[3]={1,0,0} <font color="darkgreen">
    &quot;Vector from origin of frame_a to revolute joint in the middle, resolved in frame_ia&quot;</font>;
  <font color="blue">parameter </font>SI.Position rRod2_ib[3]={-1,0,0} <font color="darkgreen">
    &quot;Vector from origin of frame_ib to revolute joint in the middle, resolved in frame_ib&quot;</font>;
  <font color="blue">parameter </font>Cv.NonSIunits.Angle_deg phi_offset=0 <font color="darkgreen">
    &quot;Relative angle offset of revolute joint at frame_b (angle = phi(t) + from_deg(phi_offset))&quot;</font>;
  <font color="blue">parameter </font>Cv.NonSIunits.Angle_deg phi_guess=0 <font color="darkgreen">
    &quot;Select the configuration such that at initial time |phi(t0) - from_deg(phi_guess)| is minimal&quot;</font>;
  <font color="blue">parameter </font>SI.Distance cylinderLength=world.defaultJointLength <font color="darkgreen">
    &quot;|Animation|if animation = true| Length of cylinders representing the revolute joints&quot;</font>;
  <font color="blue">parameter </font>SI.Distance cylinderDiameter=world.defaultJointWidth <font color="darkgreen">
    &quot;|Animation|if animation = true| Diameter of cylinders representing the revolute joints&quot;</font>;
  <font color="blue">parameter </font><A HREF="MultiBody_Types.html#MultiBody.Types.Color"
>MultiBody.Types.Color</A> cylinderColor=MultiBody.Types.Defaults.JointColor <font color="darkgreen">
    &quot;|Animation|if animation = true| Color of cylinders representing the revolute joints&quot;</font>;
  <font color="blue">parameter </font>SI.Diameter rodDiameter=1.1*cylinderDiameter <font color="darkgreen">
    &quot;|Animation|if animation = true| Diameter of the two rods connecting the revolute joints&quot;</font>;
  <font color="blue">parameter </font><A HREF="MultiBody_Types.html#MultiBody.Types.Color"
>MultiBody.Types.Color</A> rodColor=MultiBody.Types.Defaults.RodColor <font color="darkgreen">
    &quot;|Animation|if animation = true| Color of the two rods connecting the revolute joint&quot;</font>;
  <font color="blue">parameter </font>Boolean checkTotalPower=false <font color="darkgreen">
    &quot;|Advanced|| = true, if total power flowing into this component shall be determined (must be zero)&quot;</font>;
  <font color="blue">final </font><font color="blue">parameter </font>Real e_a[3]=<font color="red">Frames.normalize</font>(n_a) <font color="darkgreen">
    &quot;Unit vector along axes of rotations, resolved in frame_a&quot;</font>;
  <font color="blue">final </font><font color="blue">parameter </font>Real e_ia[3]=jointUSR.e2_ia <font color="darkgreen">
    &quot;Unit vector along axes of rotations, resolved in frame_ia&quot;</font>;
  <font color="blue">final </font><font color="blue">parameter </font>Real e_b[3]=jointUSR.revolute.e <font color="darkgreen">
    &quot;Unit vector along axes of rotations, resolved in frame_b, frame_ib and frame_im&quot;</font>;
  SI.Power totalPower=jointUSR.totalPower <font color="darkgreen">
    &quot;Total power flowing into this element, if checkTotalPower=true (otherwise dummy)&quot;</font>;
  <font color="darkgreen"></font>
  <font color="darkgreen"></font>
  <A HREF="MultiBody_Joints_Assemblies.html#MultiBody.Joints.Assemblies.JointUSR"
>JointUSR</A> jointUSR(
    animation=false,
    n1_a=n_a,
    n_b=n_b,
    phi_offset=phi_offset,
    rRod2_ib=rRod2_ib,
    showUniversalAxes=false,
    rRod1_ia=rRod1_ia,
    checkTotalPower=checkTotalPower,
    phi_guess=phi_guess);
  <font color="darkgreen"></font>
<font color="blue">protected </font>
  <font color="blue">parameter </font>Integer ndim=<font color="blue">if </font>world.enableAnimation<font color="blue"> and </font>animation<font color="blue"> then </font>1<font color="blue"> else </font>0;
  <A HREF="MultiBody_Visualizers_Advanced.html#MultiBody.Visualizers.Advanced.Shape"
>Visualizers.Advanced.Shape</A> shape_rev1[ndim](
    <font color="blue">each </font>shapeType=&quot;cylinder&quot;,
    <font color="blue">each </font>color=cylinderColor,
    <font color="blue">each </font>length=cylinderLength,
    <font color="blue">each </font>width=cylinderDiameter,
    <font color="blue">each </font>height=cylinderDiameter,
    <font color="blue">each </font>lengthDirection=e_a,
    <font color="blue">each </font>widthDirection={0,1,0},
    <font color="blue">each </font>r_shape=-e_a*(cylinderLength/2),
    <font color="blue">each </font>r=frame_a.r_0,
    <font color="blue">each </font>R=frame_a.R);
  <A HREF="MultiBody_Visualizers_Advanced.html#MultiBody.Visualizers.Advanced.Shape"
>Visualizers.Advanced.Shape</A> shape_rev2[ndim](
    <font color="blue">each </font>shapeType=&quot;cylinder&quot;,
    <font color="blue">each </font>color=cylinderColor,
    <font color="blue">each </font>length=cylinderLength,
    <font color="blue">each </font>width=cylinderDiameter,
    <font color="blue">each </font>height=cylinderDiameter,
    <font color="blue">each </font>lengthDirection=e_b,
    <font color="blue">each </font>widthDirection={0,1,0},
    <font color="blue">each </font>r_shape=-e_b*(cylinderLength/2),
    <font color="blue">each </font>r=frame_im.r_0,
    <font color="blue">each </font>R=frame_im.R);
  <A HREF="MultiBody_Visualizers_Advanced.html#MultiBody.Visualizers.Advanced.Shape"
>Visualizers.Advanced.Shape</A> shape_rev3[ndim](
    <font color="blue">each </font>shapeType=&quot;cylinder&quot;,
    <font color="blue">each </font>color=cylinderColor,
    <font color="blue">each </font>length=cylinderLength,
    <font color="blue">each </font>width=cylinderDiameter,
    <font color="blue">each </font>height=cylinderDiameter,
    <font color="blue">each </font>lengthDirection=e_b,
    <font color="blue">each </font>widthDirection={0,1,0},
    <font color="blue">each </font>r_shape=-e_b*(cylinderLength/2),
    <font color="blue">each </font>r=frame_b.r_0,
    <font color="blue">each </font>R=frame_b.R);
  <A HREF="MultiBody_Visualizers_Advanced.html#MultiBody.Visualizers.Advanced.Shape"
>Visualizers.Advanced.Shape</A> shape_rod1[ndim](
    <font color="blue">each </font>shapeType=&quot;cylinder&quot;,
    <font color="blue">each </font>color=rodColor,
    <font color="blue">each </font>length=<font color="red">Frames.length</font>(rRod1_ia),
    <font color="blue">each </font>width=rodDiameter,
    <font color="blue">each </font>height=rodDiameter,
    <font color="blue">each </font>lengthDirection=rRod1_ia,
    <font color="blue">each </font>widthDirection=e_ia,
    <font color="blue">each </font>r=frame_ia.r_0,
    <font color="blue">each </font>R=frame_ia.R);
  <A HREF="MultiBody_Visualizers_Advanced.html#MultiBody.Visualizers.Advanced.Shape"
>Visualizers.Advanced.Shape</A> shape_rod2[ndim](
    <font color="blue">each </font>shapeType=&quot;cylinder&quot;,
    <font color="blue">each </font>color=rodColor,
    <font color="blue">each </font>length=<font color="red">Frames.length</font>(rRod2_ib),
    <font color="blue">each </font>width=rodDiameter,
    <font color="blue">each </font>height=rodDiameter,
    <font color="blue">each </font>lengthDirection=rRod2_ib,
    <font color="blue">each </font>widthDirection=e_b,
    <font color="blue">each </font>r=frame_ib.r_0,
    <font color="blue">each </font>R=frame_ib.R);
<font color="blue">initial </font><font color="blue">equation </font>
  n_b = <font color="red">Frames.resolve2</font>(frame_b.R, <font color="red">Frames.resolve1</font>(frame_a.R, n_a));
<font color="blue">equation </font>
  <font color="red">connect</font>(jointUSR.frame_a, frame_a);
  <font color="red">connect</font>(jointUSR.frame_b, frame_b);
  <font color="red">connect</font>(jointUSR.frame_ia, frame_ia);
  <font color="red">connect</font>(jointUSR.frame_im, frame_im);
  <font color="red">connect</font>(jointUSR.frame_ib, frame_ib);
  <font color="red">connect</font>(jointUSR.axis, axis);
  <font color="red">connect</font>(jointUSR.bearing, bearing);
<font color="blue">end </font>JointRRR;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE JointUSR<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><IMG SRC="MultiBody.Joints.Assemblies.JointUSRI.png" ALT="MultiBody.Joints.Assemblies.JointUSR" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="MultiBody.Joints.Assemblies.JointUSR"></A><A HREF="MultiBody_Joints_Assemblies.html#MultiBody.Joints.Assemblies"
>MultiBody.Joints.Assemblies</A>.JointUSR</H2>
<B>Universal - spherical - revolute joint aggregation (no constraints, no potential states)</B><p>
<IMG SRC="MultiBody.Joints.Assemblies.JointUSRD.png" ALT="MultiBody.Joints.Assemblies.JointUSR">
<H3>Information</H3>
<PRE></pre>
<p>
This component consists of a <b>universal</b> joint at frame_a, a <b>revolute</b>
joint at frame_b and a <b>spherical</b> joint which is connected via <b>rod1</b>
to the universal and via <b>rod2</b> to the revolute joint, see the default
animation in the following figure (the axes vectors are not part of the
default animation):
</p>
<p align="center">
<IMG SRC="../Images/Joints/JointUSR.png" ALT="model Joints.Assemblies.JointUSR">
</p>
<p>
This joint aggregation has no mass and no inertia and
introduces neither constraints nor potential state variables.
It should be used in kinematic loops whenever possible since
the non-linear system of equations introduced by this joint aggregation
is solved <b>analytically</b> (i.e., a solution is always computed, if a
unique solution exists).
</p>
<p>
The universal joint is defined in the following way:
<p>
<ul>
<li> The rotation <b>axis</b> of revolute joint <b>1</b> is along parameter
     vector n1_a which is fixed in frame_a.<li>
<li> The rotation <b>axis</b> of revolute joint <b>2</b> is perpendicular to
     axis 1 and to the line connecting the universal and the spherical joint
     (= rod 1).
</ul>
<p>
The definition of axis 2 of the universal joint is performed according
to the most often occuring case. In a future release, axis 2 might
be explicitly definable via a parameter. However, the treatment is much more
complicated and the number of operations is considerably higher,
if axis 2 is not orthogonal to axis 1 and to the connecting rod.
</p>
<p>
Note, there is a <b>singularity</b> when axis 1 and the connecting rod are parallel
to each other. Therefore, if possible n1_a should be selected in such a way that it
is perpendicular to rRod1_ia in the initial configuration (i.e., the
distance to the singularity is as large as possible).
</p>
<p>
The rest of this joint aggregation is defined by the following parameters:
</p>
<ul>
<li> The position of the spherical joint with respect to the universal
     joint is defined by vector <b>rRod1_ia</b>. This vector is directed from
     frame_a to the spherical joint and is resolved in frame_ia
     (it is most simple to select frame_ia such that it is parallel to
     frame_a in the reference or initial configuration).</li>
<li> The position of the spherical joint with respect to the revolute
     joint is defined by vector <b>rRod2_ib</b>. This vector is directed from
     the inner frame of the revolute joint (frame_ib or revolute.frame_a)
     to the spherical joint and is resolved in frame_ib (note, that frame_ib
     and frame_b are parallel to each other).</li>
<li> The axis of rotation of the revolute joint is defined by axis
     vector <b>n_b</b>. It is fixed and resolved in frame_b.</li>
<li> When specifying this joint aggregation with the definitions above, <b>two</b>
     different <b>configurations</b> are possible. Via parameter <b>phi_guess</b>
     a guess value for revolute.phi(t0) at the initial time t0 is given. The configuration
     is selected that is closest to phi_guess (|revolute.phi - phi_guess| is minimal).
</ul>
<p>
An additional <b>frame_ia</b> is present. It is <b>fixed</b> in the rod
connecting the universal and the spherical joint at the
origin of <b>frame_a</b>. The placement of frame_ia on the rod
is implicitly defined by the universal joint (frame_a and frame_ia coincide
when the angles of the two revolute joints of the universal joint are zero)
and by parameter vector <b>rRod1_ia</b>, the position vector
from the origin of frame_a to the spherical joint, resolved in frame_<b>ia</b>.
</p
<p>
An additional <b>frame_ib</b> is present. It is <b>fixed</b> in the rod
connecting the revolute and the spherical joint at the side of the revolute
joint that is connected to this rod (= rod2.frame_a = revolute.frame_a).
</p>
<p>
An additional <b>frame_im</b> is present. It is <b>fixed</b> in the rod
connecting the revolute and the spherical joint at the side of the spherical
joint that is connected to this rod (= rod2.frame_b).
It is always parallel to <b>frame_ib</b>.
</p>
<p>
The easiest way to define the parameters of this joint is by moving the
MultiBody system in a <b>reference configuration</b> where <b>all frames</b>
of all components are <b>parallel</b> to each other (alternatively,
at least frame_a and frame_ia of the JointUSR joint
should be parallel to each other when defining an instance of this
component).
</p>
<p>
In the public interface of the JointUSR joint, the following
(final) <b>parameters</b> are provided:
</p>
<pre>
  <b>parameter</b> Real rod1Length(unit="m")  "Length of rod 1";
  <b>parameter</b> Real eRod1_ia[3] "Unit vector along rod 1, resolved in frame_ia";
  <b>parameter</b> Real e2_ia  [3]  "Unit vector along axis 2, resolved in frame_ia";
</pre>
<p>
This allows a more convenient definition of data which is related to rod 1.
For example, if a box shall be connected at frame_ia directing from
the origin of frame_a to the middle of rod 1, this might be defined as:
</p>
<pre>
    MultiBody.Joints.Assemblies.JointUSP jointUSR(rRod1_ia={1.2, 1, 0.2});
    MultiBody.Visualizers.FixedShape     shape(shapeType       = "box",
                                               lengthDirection = jointUSR.eRod1_ia,
                                               widthDirection  = jointUSR.e2_ia,
                                               length          = jointUSR.rod1Length/2,
                                               width           = jointUSR.rod1Length/10);
  <b>equation</b>
    <b>connect</b>(jointUSP.frame_ia, shape.frame_a);
</pre>
<pre> </PRE>
<H3>Parameters</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>animation</TD><TD>true</TD><TD>= true, if animation shall be enabled</TD></TR>
<TR><TD>showUniversalAxes</TD><TD>true</TD><TD> = true, if universal joint shall be visualized with two cylinders, otherwise with a sphere (provided animation=true)</TD></TR>
<TR><TD>n1_a</TD><TD>{0,0,1}</TD><TD>Axis 1 of universal joint fixed and resolved in frame_a (axis 2 is orthogonal to axis 1 and to rod 1)</TD></TR>
<TR><TD>n_b</TD><TD>{0,0,1}</TD><TD>Axis of revolute joint fixed and resolved in frame_b</TD></TR>
<TR><TD>rRod1_ia[3]</TD><TD>{1,0,0}</TD><TD>Vector from origin of frame_a to spherical joint, resolved in frame_ia [m]</TD></TR>
<TR><TD>rRod2_ib[3]</TD><TD>{-1,0,0}</TD><TD>Vector from origin of frame_ib to spherical joint, resolved in frame_ib [m]</TD></TR>
<TR><TD>phi_offset</TD><TD>0</TD><TD>Relative angle offset of revolute joint (angle = phi(t) + from_deg(phi_offset)) [deg]</TD></TR>
<TR><TD>phi_guess</TD><TD>0</TD><TD>Select the configuration such that at initial time |phi(t0) - from_deg(phi_guess)| is minimal [deg]</TD></TR>
<TR><TD>sphereDiameter</TD><TD>world.defaultJointLength</TD><TD> Diameter of the spheres representing the universal and the spherical joint [m]</TD></TR>
<TR><TD>sphereColor</TD><TD>MultiBody.Types.Defaults.JointColor</TD><TD> Color of the spheres representing the universal and the spherical joint</TD></TR>
<TR><TD>rod1Diameter</TD><TD>sphereDiameter/Types.Defaults.JointRodDiameterFraction</TD><TD> Diameter of rod 1 connecting the universal and the spherical joint [m]</TD></TR>
<TR><TD>rod1Color</TD><TD>MultiBody.Types.Defaults.RodColor</TD><TD> Color of rod 1 connecting the universal and the spherical joint</TD></TR>
<TR><TD>rod2Diameter</TD><TD>rod1Diameter</TD><TD> Diameter of rod 2 connecting the revolute and the spherical joint [m]</TD></TR>
<TR><TD>rod2Color</TD><TD>rod1Color</TD><TD> Color of rod 2 connecting the revolute and the spherical joint</TD></TR>
<TR><TD>revoluteDiameter</TD><TD>world.defaultJointWidth</TD><TD> Diameter of cylinder representing the revolute joint [m]</TD></TR>
<TR><TD>revoluteLength</TD><TD>world.defaultJointLength</TD><TD> Length of cylinder representing the revolute joint [m]</TD></TR>
<TR><TD>revoluteColor</TD><TD>MultiBody.Types.Defaults.JointColor</TD><TD> Color of cylinder representing the revolute joint</TD></TR>
<TR><TD>cylinderLength</TD><TD>world.defaultJointLength</TD><TD> Length of cylinders representing the two universal joint axes [m]</TD></TR>
<TR><TD>cylinderDiameter</TD><TD>world.defaultJointWidth</TD><TD> Diameter of cylinders representing the two universal joint axes [m]</TD></TR>
<TR><TD>cylinderColor</TD><TD>Types.Defaults.JointColor</TD><TD> Color of cylinders representing the two universal joint axes</TD></TR>
<TR><TD>checkTotalPower</TD><TD>false</TD><TD> = true, if total power flowing into this component shall be determined (must be zero)</TD></TR>
</TABLE>
<H3>Modelica definition</H3>
<PRE>
<font color="blue">model</font> JointUSR <font color="darkgreen">
  &quot;Universal - spherical - revolute joint aggregation (no constraints, no potential states)&quot;</font>

  <font color="darkgreen"></font>
  <font color="blue">import </font>SI = Modelica.SIunits;
  <font color="blue">import </font>Cv = Modelica.SIunits.Conversions;
  <font color="darkgreen"></font>
  <font color="blue">extends </font><A HREF="MultiBody_Interfaces.html#MultiBody.Interfaces.PartialTwoFrames"
>MultiBody.Interfaces.PartialTwoFrames</A>;
  <A HREF="MultiBody_Interfaces.html#MultiBody.Interfaces.Frame_a"
>MultiBody.Interfaces.Frame_a</A> frame_ia;
  <A HREF="MultiBody_Interfaces.html#MultiBody.Interfaces.Frame_b"
>MultiBody.Interfaces.Frame_b</A> frame_ib;
  <A HREF="MultiBody_Interfaces.html#MultiBody.Interfaces.Frame_b"
>MultiBody.Interfaces.Frame_b</A> frame_im;
  Modelica.Mechanics.Rotational.Interfaces.Flange_a axis;
  Modelica.Mechanics.Rotational.Interfaces.Flange_b bearing;
  <font color="darkgreen"></font>
  <font color="blue">parameter </font>Boolean animation=true <font color="darkgreen">&quot;= true, if animation shall be enabled&quot;</font>;
  <font color="blue">parameter </font>Boolean showUniversalAxes=true <font color="darkgreen">
    &quot; = true, if universal joint shall be visualized with two cylinders, otherwise with a sphere (provided animation=true)&quot;</font>;
  <font color="blue">parameter </font><A HREF="MultiBody_Types.html#MultiBody.Types.Axis"
>MultiBody.Types.Axis</A> n1_a={0,0,1} <font color="darkgreen">
    &quot;Axis 1 of universal joint fixed and resolved in frame_a (axis 2 is orthogonal to axis 1 and to rod 1)&quot;</font>;
  <font color="blue">parameter </font><A HREF="MultiBody_Types.html#MultiBody.Types.Axis"
>MultiBody.Types.Axis</A> n_b={0,0,1} <font color="darkgreen">
    &quot;Axis of revolute joint fixed and resolved in frame_b&quot;</font>;
  <font color="blue">parameter </font>SI.Position rRod1_ia[3]={1,0,0} <font color="darkgreen">
    &quot;Vector from origin of frame_a to spherical joint, resolved in frame_ia&quot;</font>;
  <font color="blue">parameter </font>SI.Position rRod2_ib[3]={-1,0,0} <font color="darkgreen">
    &quot;Vector from origin of frame_ib to spherical joint, resolved in frame_ib&quot;</font>;
  <font color="blue">parameter </font>Cv.NonSIunits.Angle_deg phi_offset=0 <font color="darkgreen">
    &quot;Relative angle offset of revolute joint (angle = phi(t) + from_deg(phi_offset))&quot;</font>;
  <font color="blue">parameter </font>Cv.NonSIunits.Angle_deg phi_guess=0 <font color="darkgreen">
    &quot;Select the configuration such that at initial time |phi(t0) - from_deg(phi_guess)| is minimal&quot;</font>;
  <font color="blue">parameter </font>SI.Diameter sphereDiameter=world.defaultJointLength <font color="darkgreen">
    &quot;|Animation|if animation = true| Diameter of the spheres representing the universal and the spherical joint&quot;</font>;
  <font color="blue">parameter </font><A HREF="MultiBody_Types.html#MultiBody.Types.Color"
>MultiBody.Types.Color</A> sphereColor=MultiBody.Types.Defaults.JointColor <font color="darkgreen">
    &quot;|Animation|if animation = true| Color of the spheres representing the universal and the spherical joint&quot;</font>;
  <font color="blue">parameter </font>SI.Diameter rod1Diameter=sphereDiameter/Types.Defaults.
      JointRodDiameterFraction <font color="darkgreen">
    &quot;|Animation|if animation = true| Diameter of rod 1 connecting the universal and the spherical joint&quot;</font>;
  <font color="blue">parameter </font><A HREF="MultiBody_Types.html#MultiBody.Types.Color"
>MultiBody.Types.Color</A> rod1Color=MultiBody.Types.Defaults.RodColor <font color="darkgreen">
    &quot;|Animation|if animation = true| Color of rod 1 connecting the universal and the spherical joint&quot;</font>;
  <font color="blue">parameter </font>SI.Diameter rod2Diameter=rod1Diameter <font color="darkgreen">
    &quot;|Animation|if animation = true| Diameter of rod 2 connecting the revolute and the spherical joint&quot;</font>;
  <font color="blue">parameter </font><A HREF="MultiBody_Types.html#MultiBody.Types.Color"
>MultiBody.Types.Color</A> rod2Color=rod1Color <font color="darkgreen">
    &quot;|Animation|if animation = true| Color of rod 2 connecting the revolute and the spherical joint&quot;</font>;
  <font color="blue">parameter </font>SI.Diameter revoluteDiameter=world.defaultJointWidth <font color="darkgreen">
    &quot;|Animation|if animation = true| Diameter of cylinder representing the revolute joint&quot;</font>;
  <font color="blue">parameter </font>SI.Distance revoluteLength=world.defaultJointLength <font color="darkgreen">
    &quot;|Animation|if animation = true| Length of cylinder representing the revolute joint&quot;</font>;
  <font color="blue">parameter </font><A HREF="MultiBody_Types.html#MultiBody.Types.Color"
>MultiBody.Types.Color</A> revoluteColor=MultiBody.Types.Defaults.JointColor <font color="darkgreen">
    &quot;|Animation|if animation = true| Color of cylinder representing the revolute joint&quot;</font>;
  <font color="blue">parameter </font>SI.Distance cylinderLength=world.defaultJointLength <font color="darkgreen">
    &quot;|Animation|if animation = true and showUniversalAxes| Length of cylinders representing the two universal joint axes&quot;</font>;
  <font color="blue">parameter </font>SI.Distance cylinderDiameter=world.defaultJointWidth <font color="darkgreen">
    &quot;|Animation|if animation = true and showUniversalAxes| Diameter of cylinders representing the two universal joint axes&quot;</font>;
  <font color="blue">parameter </font><A HREF="MultiBody_Types.html#MultiBody.Types.Color"
>MultiBody.Types.Color</A> cylinderColor=Types.Defaults.JointColor <font color="darkgreen">
    &quot;|Animation|if animation = true and showUniversalAxes| Color of cylinders representing the two universal joint axes&quot;</font>;
  <font color="darkgreen"></font>
  <font color="blue">parameter </font>Boolean checkTotalPower=false <font color="darkgreen">
    &quot;|Advanced|| = true, if total power flowing into this component shall be determined (must be zero)&quot;</font>;
  <font color="blue">final </font><font color="blue">parameter </font>Real eRod1_ia[3]=rod1.eRod_ia <font color="darkgreen">
    &quot;Unit vector from origin of frame_a to origin of spherical joint, resolved in frame_ia&quot;</font>;
  <font color="blue">final </font><font color="blue">parameter </font>Real e2_ia[3]=rod1.e2_ia <font color="darkgreen">
    &quot;Unit vector in direction of axis 2 of universal joint, resolved in frame_ia&quot;</font>;
  <font color="blue">final </font><font color="blue">parameter </font>SI.Distance rod1Length=rod1.rodLength <font color="darkgreen">
    &quot;Length of rod 1 (= distance between universal and spherical joint&quot;</font>;
  SI.Power totalPower <font color="darkgreen">
    &quot;Total power flowing into this element, if checkTotalPower=true (otherwise dummy)&quot;</font>;
  SI.Position aux <font color="darkgreen">
    &quot;Denominator used to compute force in rod connecting universal and spherical joint&quot;</font>;
  <font color="darkgreen"></font>
  <A HREF="MultiBody_Joints_Internal.html#MultiBody.Joints.Internal.RevoluteWithLengthConstraint"
>MultiBody.Joints.Internal.RevoluteWithLengthConstraint</A> revolute(
    animation=animation,
    lengthConstraint=rod1Length,
    n=n_b,
    phi_offset=phi_offset,
    phi_guess=phi_guess,
    cylinderDiameter=revoluteDiameter,
    cylinderLength=revoluteLength,
    cylinderColor=revoluteColor,
    axisTorqueBalance=false);
  <A HREF="MultiBody_Joints.html#MultiBody.Joints.UniversalSpherical"
>MultiBody.Joints.UniversalSpherical</A> rod1(
    animation=animation,
    showUniversalAxes=showUniversalAxes,
    rRod_ia=rRod1_ia,
    n1_a=n1_a,
    sphereDiameter=sphereDiameter,
    sphereColor=sphereColor,
    rodWidth=rod1Diameter,
    rodHeight=rod1Diameter,
    rodColor=rod1Color,
    cylinderLength=cylinderLength,
    cylinderDiameter=cylinderDiameter,
    cylinderColor=cylinderColor,
    kinematicConstraint=false);
  <A HREF="MultiBody_Parts.html#MultiBody.Parts.FixedTranslation"
>MultiBody.Parts.FixedTranslation</A> rod2(
    animation=animation,
    width=rod2Diameter,
    height=rod2Diameter,
    color=rod2Color,
    r=rRod2_ib);
  <A HREF="MultiBody_Sensors.html#MultiBody.Sensors.RelativeSensor"
>MultiBody.Sensors.RelativeSensor</A> relativeSensor(animation=false);
  Modelica.Blocks.Sources.Constant position_b(k=rRod2_ib);
<font color="blue">equation </font>
  <font color="red">defineRoot</font>(frame_ib.R);
  <font color="darkgreen"></font>
  <font color="darkgreen">/* Compute the unknown force in the rod of the rod1 joint
     by a torque balance at the revolute joint:
       0 = revolute.frame_b.t + frame_ib.t + frame_im.t + cross(rRod2_ib, frame_im.f)
           + cross(r_ib, -rod1.f_b_a1)
           + cross(r_ib, Frames.resolve2(rod1.R_rel, rod1.f_rod*rod1.eRod1_ia))
     The condition is that the projection of the torque in the revolute
     joint along the axis of the revolute joint is equal to the driving
     axis torque in the flange:
       -revolute.tau = revolute.e*frame_b.t
     Therefore, we have
        tau = e*(frame_ib.t  + frame_im.t + cross(rRod2_ib, frame_im.f)
              + cross(rRod2_ib, -rod1.f_b_a1))
              + e*cross(rRod2_ib, Frames.resolve2(rod1.R_rel, rod1.f_rod*rod1.eRod_a))
            = e*(frame_ib.t + frame_im.t + cross(rRod2_ib, frame_im.f)
              + cross(rRod2_ib, -rod.f_b_a1))
              + rod1.f_rod*e*cross(rRod2_ib, Frames.resolve2(rod1.R_rel, rod1.eRod_a))
     Solving this equation for f_rod results in
       rod1.f_rod = (-tau - e*(frame_ib.t + frame_im.t + cross(rRod2_ib, frame_im.f)
                   + cross(rRod2_ib, -rod1.f_b_a1)))
                   / (cross(e,rRod2_ib)*Frames.resolve2(rod1.R_rel, rod1.eRod_a)))
     Additionally, a guard against division by zero is introduced
  */</font>
  aux = <font color="red">cross</font>(revolute.e, rRod2_ib)*<font color="red">Frames.resolve2</font>(rod1.R_rel, rod1.eRod_a);
  rod1.f_rod = (-revolute.tau - revolute.e*(frame_ib.t + frame_im.t + <font color="red">cross</font>(
    rRod2_ib, frame_im.f) - <font color="red">cross</font>(rRod2_ib, <font color="red">Frames.resolve2</font>(rod1.R_rel, rod1.
    f_b_a1))))/<font color="red">noEvent</font>(<font color="blue">if </font><font color="red">abs</font>(aux) &lt; 1.e-10<font color="blue"> then </font>1.e-10<font color="blue"> else </font>aux);
  <font color="darkgreen"></font>
  <font color="darkgreen">// Measure power for test purposes</font>
  <font color="blue">if </font>checkTotalPower<font color="blue"> then</font>
    totalPower = frame_a.f*<font color="red">Frames.resolve2</font>(frame_a.R, <font color="red">der</font>(frame_a.r_0)) +
      frame_b.f*<font color="red">Frames.resolve2</font>(frame_b.R, <font color="red">der</font>(frame_b.r_0)) + frame_ia.f*<font color="red">
      Frames.resolve2</font>(frame_ia.R, <font color="red">der</font>(frame_ia.r_0)) + frame_ib.f*<font color="red">
      Frames.resolve2</font>(frame_ib.R, <font color="red">der</font>(frame_ib.r_0)) + frame_im.f*<font color="red">
      Frames.resolve2</font>(frame_im.R, <font color="red">der</font>(frame_im.r_0)) + frame_a.t*<font color="red">
      Frames.angularVelocity2</font>(frame_a.R, <font color="red">der</font>(frame_a.R)) + frame_b.t*<font color="red">
      Frames.angularVelocity2</font>(frame_b.R, <font color="red">der</font>(frame_b.R)) + frame_ia.t*<font color="red">
      Frames.angularVelocity2</font>(frame_ia.R, <font color="red">der</font>(frame_ia.R)) + frame_ib.t*<font color="red">
      Frames.angularVelocity2</font>(frame_ib.R, <font color="red">der</font>(frame_ib.R)) + frame_im.t*<font color="red">
      Frames.angularVelocity2</font>(frame_im.R, <font color="red">der</font>(frame_im.R)) + axis.tau*<font color="red">der</font>(axis.
      phi) + bearing.tau*<font color="red">der</font>(bearing.phi);
  <font color="blue">else</font>
    totalPower = 0;
  <font color="blue">end if</font>;
  <font color="darkgreen"></font>
  <font color="red">connect</font>(revolute.frame_b, rod2.frame_a);
  <font color="red">connect</font>(rod2.frame_b, rod1.frame_b);
  <font color="red">connect</font>(revolute.frame_a, frame_b);
  <font color="red">connect</font>(rod2.frame_a, frame_ib);
  <font color="red">connect</font>(rod1.frame_a, frame_a);
  <font color="red">connect</font>(relativeSensor.frame_b, frame_a);
  <font color="red">connect</font>(relativeSensor.frame_a, frame_b);
  <font color="red">connect</font>(relativeSensor.outPort, revolute.position_a);
  <font color="red">connect</font>(position_b.outPort, revolute.position_b);
  <font color="red">connect</font>(rod2.frame_b, frame_im);
  <font color="red">connect</font>(rod1.frame_ia, frame_ia);
  <font color="red">connect</font>(revolute.axis, axis);
  <font color="red">connect</font>(revolute.bearing, bearing);
<font color="blue">end </font>JointUSR;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE JointUSP<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><IMG SRC="MultiBody.Joints.Assemblies.JointUSPI.png" ALT="MultiBody.Joints.Assemblies.JointUSP" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="MultiBody.Joints.Assemblies.JointUSP"></A><A HREF="MultiBody_Joints_Assemblies.html#MultiBody.Joints.Assemblies"
>MultiBody.Joints.Assemblies</A>.JointUSP</H2>
<B>Universal - spherical - prismatic joint aggregation (no constraints, no potential states)</B><p>
<IMG SRC="MultiBody.Joints.Assemblies.JointUSPD.png" ALT="MultiBody.Joints.Assemblies.JointUSP">
<H3>Information</H3>
<PRE></pre>
<p>
This component consists of a <b>universal</b> joint at frame_a, a <b>prismatic</b>
joint at frame_b and a <b>spherical</b> joint which is connected via <b>rod1</b>
to the universal and via <b>rod2</b> to the prismatic joint, see the default
animation in the following figure (the axes vectors are not part of the
default animation):
</p>
<p align="center">
<IMG SRC="../Images/Joints/JointUSP.png" ALT="model Joints.Assemblies.JointUSP">
</p>
<p>
This joint aggregation has no mass and no inertia and
introduces neither constraints nor potential state variables.
It should be used in kinematic loops whenever possible since
the non-linear system of equations introduced by this joint aggregation
is solved <b>analytically</b> (i.e., a solution is always computed, if a
unique solution exists).
</p>
<p>
The universal joint is defined in the following way:
<p>
<ul>
<li> The rotation <b>axis</b> of revolute joint <b>1</b> is along parameter
     vector n1_a which is fixed in frame_a.<li>
<li> The rotation <b>axis</b> of revolute joint <b>2</b> is perpendicular to
     axis 1 and to the line connecting the universal and the spherical joint
     (= rod 1).
</ul>
<p>
The definition of axis 2 of the universal joint is performed according
to the most often occuring case. In a future release, axis 2 might
be explicitly definable via a parameter. However, the treatment is much more
complicated and the number of operations is considerably higher,
if axis 2 is not orthogonal to axis 1 and to the connecting rod.
</p>
<p>
Note, there is a <b>singularity</b> when axis 1 and the connecting rod are parallel
to each other. Therefore, if possible n1_a should be selected in such a way that it
is perpendicular to rRod1_ia in the initial configuration (i.e., the
distance to the singularity is as large as possible).
</p>
<p>
The rest of this joint aggregation is defined by the following parameters:
</p>
<ul>
<li> The position of the spherical joint with respect to the universal
     joint is defined by vector <b>rRod1_ia</b>. This vector is directed from
     frame_a to the spherical joint and is resolved in frame_ia
     (it is most simple to select frame_ia such that it is parallel to
     frame_a in the reference or initial configuration).</li>
<li> The position of the spherical joint with respect to the prismatic
     joint is defined by vector <b>rRod2_ib</b>. This vector is directed from
     the inner frame of the prismatic joint (frame_ib or prismatic.frame_a)
     to the spherical joint and is resolved in frame_ib (note, that frame_ib
     and frame_b are parallel to each other).</li>
<li> The axis of translation of the prismatic joint is defined by axis
     vector <b>n_b</b>. It is fixed and resolved in frame_b.</li>
<li> The two frames of the prismatic joint, i.e., frame_b and frame_ib,
     are parallel to each other.
     The distance between the origins of these two frames along axis n_b
     is equal to "prismatic.s(t) + s_offset", where "prismatic.s(t)" is
     a time varying variable and "s_offset" is a fixed, constant offset
     parameter.</li>
<li> When specifying this joint aggregation with the definitions above, <b>two</b>
     different <b>configurations</b> are possible. Via parameter <b>s_guess</b>
     a guess value for prismatic.s(t0) at the initial time t0 is given. The configuration
     is selected that is closest to s_guess (|prismatic.s - s_guess| is minimal).
</ul>
<p>
An additional <b>frame_ia</b> is present. It is <b>fixed</b> in the rod
connecting the universal and the spherical joint at the
origin of <b>frame_a</b>. The placement of frame_ia on the rod
is implicitly defined by the universal joint (frame_a and frame_ia coincide
when the angles of the two revolute joints of the universal joint are zero)
and by parameter vector <b>rRod1_ia</b>, the position vector
from the origin of frame_a to the spherical joint, resolved in frame_<b>ia</b>.
</p
<p>
An additional <b>frame_ib</b> is present. It is <b>fixed</b> in the rod
connecting the prismatic and the spherical joint at the side of the prismatic
joint that is connected to this rod (= rod2.frame_a = prismatic.frame_a).
It is always parallel to <b>frame_b</b>.
</p>
<p>
An additional <b>frame_im</b> is present. It is <b>fixed</b> in the rod
connecting the prismatic and the spherical joint at the side of the spherical
joint that is connected to this rod (= rod2.frame_b).
It is always parallel to <b>frame_b</b>.
</p>
<p>
The easiest way to define the parameters of this joint is by moving the
MultiBody system in a <b>reference configuration</b> where <b>all frames</b>
of all components are <b>parallel</b> to each other (alternatively,
at least frame_a and frame_ia of the JointUSP joint
should be parallel to each other when defining an instance of this
component).
</p>
<p>
In the public interface of the JointUSP joint, the following
(final) <b>parameters</b> are provided:
</p>
<pre>
  <b>parameter</b> Real rod1Length(unit="m")  "Length of rod 1";
  <b>parameter</b> Real eRod1_ia[3] "Unit vector along rod 1, resolved in frame_ia";
  <b>parameter</b> Real e2_ia  [3]  "Unit vector along axis 2, resolved in frame_ia";
</pre>
<p>
This allows a more convenient definition of data which is related to rod 1.
For example, if a box shall be connected at frame_ia directing from
the origin of frame_a to the middle of rod 1, this might be defined as:
</p>
<pre>
    MultiBody.Joints.Assemblies.JointUSP jointUSP(rRod1_ia={1.2, 1, 0.2});
    MultiBody.Visualizers.FixedShape     shape(shapeType       = "box",
                                               lengthDirection = jointUSP.eRod1_ia,
                                               widthDirection  = jointUSP.e2_ia,
                                               length          = jointUSP.rod1Length/2,
                                               width           = jointUSP.rod1Length/10);
  <b>equation</b>
    <b>connect</b>(jointUSP.frame_ia, shape.frame_a);
</pre>
<pre> </PRE>
<H3>Parameters</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>animation</TD><TD>true</TD><TD>= true, if animation shall be enabled</TD></TR>
<TR><TD>showUniversalAxes</TD><TD>true</TD><TD> = true, if universal joint shall be visualized with two cylinders, otherwise with a sphere (provided animation=true)</TD></TR>
<TR><TD>n1_a</TD><TD>{0,0,1}</TD><TD>Axis 1 of universal joint fixed and resolved in frame_a (axis 2 is orthogonal to axis 1 and to rod 1)</TD></TR>
<TR><TD>n_b</TD><TD>{-1,0,0}</TD><TD>Axis of prismatic joint fixed and resolved in frame_b</TD></TR>
<TR><TD>rRod1_ia[3]</TD><TD>{1,0,0}</TD><TD>Vector from origin of frame_a to spherical joint, resolved in frame_ia [m]</TD></TR>
<TR><TD>rRod2_ib[3]</TD><TD>{-1,0,0}</TD><TD>Vector from origin of frame_ib to spherical joint, resolved in frame_ib (frame_ib is parallel to frame_b) [m]</TD></TR>
<TR><TD>s_offset</TD><TD>0</TD><TD>Relative distance offset of prismatic joint (distance between the prismatic joint frames = s(t) + s_offset) [m]</TD></TR>
<TR><TD>s_guess</TD><TD>0</TD><TD>Select the configuration such that at initial time |s(t0)-s_guess| is minimal [m]</TD></TR>
<TR><TD>sphereDiameter</TD><TD>world.defaultJointLength</TD><TD> Diameter of the spheres representing the universal and the spherical joint [m]</TD></TR>
<TR><TD>sphereColor</TD><TD>Types.Defaults.JointColor</TD><TD> Color of the spheres representing the universal and the spherical joint</TD></TR>
<TR><TD>rod1Diameter</TD><TD>sphereDiameter/Types.Defaults.JointRodDiameterFraction</TD><TD> Diameter of rod 1 connecting the universal and the spherical joint [m]</TD></TR>
<TR><TD>rod1Color</TD><TD>Types.Defaults.RodColor</TD><TD> Color of rod 1 connecting the universal and the spherical joint</TD></TR>
<TR><TD>rod2Diameter</TD><TD>rod1Diameter</TD><TD> Diameter of rod 2 connecting the prismatic and the spherical joint [m]</TD></TR>
<TR><TD>rod2Color</TD><TD>rod1Color</TD><TD> Color of rod 2 connecting the prismatic and the spherical joint</TD></TR>
<TR><TD>boxWidthDirection</TD><TD>{0,1,0}</TD><TD> Vector in width direction of prismatic joint, resolved in frame_b</TD></TR>
<TR><TD>boxWidth</TD><TD>world.defaultJointWidth</TD><TD> Width of prismatic joint box [m]</TD></TR>
<TR><TD>boxHeight</TD><TD>boxWidth</TD><TD> Height of prismatic joint box [m]</TD></TR>
<TR><TD>boxColor</TD><TD>sphereColor</TD><TD> Color of prismatic joint box</TD></TR>
<TR><TD>cylinderLength</TD><TD>world.defaultJointLength</TD><TD> Length of cylinders representing the two universal joint axes [m]</TD></TR>
<TR><TD>cylinderDiameter</TD><TD>world.defaultJointWidth</TD><TD> Diameter of cylinders representing the two universal joint axes [m]</TD></TR>
<TR><TD>cylinderColor</TD><TD>Types.Defaults.JointColor</TD><TD> Color of cylinders representing the two universal joint axes</TD></TR>
<TR><TD>checkTotalPower</TD><TD>false</TD><TD> = true, if total power flowing into this component shall be determined (must be zero)</TD></TR>
</TABLE>
<H3>Modelica definition</H3>
<PRE>
<font color="blue">model</font> JointUSP <font color="darkgreen">
  &quot;Universal - spherical - prismatic joint aggregation (no constraints, no potential states)&quot;</font>

  <font color="darkgreen"></font>
  <font color="blue">import </font>SI = Modelica.SIunits;
  <font color="darkgreen"></font>
  <font color="blue">extends </font><A HREF="MultiBody_Interfaces.html#MultiBody.Interfaces.PartialTwoFrames"
>MultiBody.Interfaces.PartialTwoFrames</A>;
  <A HREF="MultiBody_Interfaces.html#MultiBody.Interfaces.Frame_a"
>MultiBody.Interfaces.Frame_a</A> frame_ia;
  <A HREF="MultiBody_Interfaces.html#MultiBody.Interfaces.Frame_b"
>MultiBody.Interfaces.Frame_b</A> frame_ib;
  <A HREF="MultiBody_Interfaces.html#MultiBody.Interfaces.Frame_b"
>MultiBody.Interfaces.Frame_b</A> frame_im;
  Modelica.Mechanics.Translational.Interfaces.Flange_a axis;
  Modelica.Mechanics.Translational.Interfaces.Flange_b bearing;
  <font color="darkgreen"></font>
  <font color="blue">parameter </font>Boolean animation=true <font color="darkgreen">&quot;= true, if animation shall be enabled&quot;</font>;
  <font color="blue">parameter </font>Boolean showUniversalAxes=true <font color="darkgreen">
    &quot; = true, if universal joint shall be visualized with two cylinders, otherwise with a sphere (provided animation=true)&quot;</font>;
  <font color="blue">parameter </font><A HREF="MultiBody_Types.html#MultiBody.Types.Axis"
>MultiBody.Types.Axis</A> n1_a={0,0,1} <font color="darkgreen">
    &quot;Axis 1 of universal joint fixed and resolved in frame_a (axis 2 is orthogonal to axis 1 and to rod 1)&quot;</font>;
  <font color="blue">parameter </font><A HREF="MultiBody_Types.html#MultiBody.Types.Axis"
>MultiBody.Types.Axis</A> n_b={-1,0,0} <font color="darkgreen">
    &quot;Axis of prismatic joint fixed and resolved in frame_b&quot;</font>;
  <font color="blue">parameter </font>SI.Position rRod1_ia[3]={1,0,0} <font color="darkgreen">
    &quot;Vector from origin of frame_a to spherical joint, resolved in frame_ia&quot;</font>;
  <font color="blue">parameter </font>SI.Position rRod2_ib[3]={-1,0,0} <font color="darkgreen">
    &quot;Vector from origin of frame_ib to spherical joint, resolved in frame_ib (frame_ib is parallel to frame_b)&quot;</font>;
  <font color="blue">parameter </font>SI.Position s_offset=0 <font color="darkgreen">
    &quot;Relative distance offset of prismatic joint (distance between the prismatic joint frames = s(t) + s_offset)&quot;</font>;
  <font color="blue">parameter </font>SI.Position s_guess=0 <font color="darkgreen">
    &quot;Select the configuration such that at initial time |s(t0)-s_guess| is minimal&quot;</font>;
  <font color="blue">parameter </font>SI.Diameter sphereDiameter=world.defaultJointLength <font color="darkgreen">
    &quot;|Animation|if animation = true| Diameter of the spheres representing the universal and the spherical joint&quot;</font>;
  <font color="blue">parameter </font><A HREF="MultiBody_Types.html#MultiBody.Types.Color"
>MultiBody.Types.Color</A> sphereColor=Types.Defaults.JointColor <font color="darkgreen">
    &quot;|Animation|if animation = true| Color of the spheres representing the universal and the spherical joint&quot;</font>;
  <font color="blue">parameter </font>SI.Diameter rod1Diameter=sphereDiameter/Types.Defaults.
      JointRodDiameterFraction <font color="darkgreen">
    &quot;|Animation|if animation = true| Diameter of rod 1 connecting the universal and the spherical joint&quot;</font>;
  <font color="blue">parameter </font><A HREF="MultiBody_Types.html#MultiBody.Types.Color"
>MultiBody.Types.Color</A> rod1Color=Types.Defaults.RodColor <font color="darkgreen">
    &quot;|Animation|if animation = true| Color of rod 1 connecting the universal and the spherical joint&quot;</font>;
  <font color="blue">parameter </font>SI.Diameter rod2Diameter=rod1Diameter <font color="darkgreen">
    &quot;|Animation|if animation = true| Diameter of rod 2 connecting the prismatic and the spherical joint&quot;</font>;
  <font color="blue">parameter </font><A HREF="MultiBody_Types.html#MultiBody.Types.Color"
>MultiBody.Types.Color</A> rod2Color=rod1Color <font color="darkgreen">
    &quot;|Animation|if animation = true| Color of rod 2 connecting the prismatic and the spherical joint&quot;</font>;
  <font color="blue">parameter </font><A HREF="MultiBody_Types.html#MultiBody.Types.Axis"
>MultiBody.Types.Axis</A> boxWidthDirection={0,1,0} <font color="darkgreen">
    &quot;|Animation|if animation = true| Vector in width direction of prismatic joint, resolved in frame_b&quot;</font>;
  <font color="blue">parameter </font>SI.Distance boxWidth=world.defaultJointWidth <font color="darkgreen">
    &quot;|Animation|if animation = true| Width of prismatic joint box&quot;</font>;
  <font color="blue">parameter </font>SI.Distance boxHeight=boxWidth <font color="darkgreen">
    &quot;|Animation|if animation = true| Height of prismatic joint box&quot;</font>;
  <font color="blue">parameter </font><A HREF="MultiBody_Types.html#MultiBody.Types.Color"
>MultiBody.Types.Color</A> boxColor=sphereColor <font color="darkgreen">
    &quot;|Animation|if animation = true| Color of prismatic joint box&quot;</font>;
  <font color="blue">parameter </font>SI.Distance cylinderLength=world.defaultJointLength <font color="darkgreen">
    &quot;|Animation|if animation = true and showUniversalAxes| Length of cylinders representing the two universal joint axes&quot;</font>;
  <font color="blue">parameter </font>SI.Distance cylinderDiameter=world.defaultJointWidth <font color="darkgreen">
    &quot;|Animation|if animation = true and showUniversalAxes| Diameter of cylinders representing the two universal joint axes&quot;</font>;
  <font color="blue">parameter </font><A HREF="MultiBody_Types.html#MultiBody.Types.Color"
>MultiBody.Types.Color</A> cylinderColor=Types.Defaults.JointColor <font color="darkgreen">
    &quot;|Animation|if animation = true and showUniversalAxes| Color of cylinders representing the two universal joint axes&quot;</font>;
  <font color="darkgreen"></font>
  <font color="blue">parameter </font>Boolean checkTotalPower=false <font color="darkgreen">
    &quot;|Advanced|| = true, if total power flowing into this component shall be determined (must be zero)&quot;</font>;
  <font color="blue">final </font><font color="blue">parameter </font>Real eRod1_ia[3]=rod1.eRod_ia <font color="darkgreen">
    &quot;Unit vector from origin of frame_a to origin of spherical joint, resolved in frame_ia&quot;</font>;
  <font color="blue">final </font><font color="blue">parameter </font>Real e2_ia[3]=rod1.e2_ia <font color="darkgreen">
    &quot;Unit vector in direction of axis 2 of universal joint, resolved in frame_ia&quot;</font>;
  <font color="blue">final </font><font color="blue">parameter </font>SI.Distance rod1Length=rod1.rodLength <font color="darkgreen">
    &quot;Length of rod 1 (= distance between universal and spherical joint&quot;</font>;
  SI.Power totalPower <font color="darkgreen">
    &quot;Total power flowing into this element, if checkTotalPower=true (otherwise dummy)&quot;</font>;
  <font color="darkgreen"></font>
  <A HREF="MultiBody_Joints_Internal.html#MultiBody.Joints.Internal.PrismaticWithLengthConstraint"
>MultiBody.Joints.Internal.PrismaticWithLengthConstraint</A> prismatic(
    animation=animation,
    length=rod1.rodLength,
    n=n_b,
    s_offset=s_offset,
    s_guess=s_guess,
    boxWidthDirection=boxWidthDirection,
    boxWidth=boxWidth,
    boxHeight=boxHeight,
    boxColor=boxColor,
    axisForceBalance=false);
  <A HREF="MultiBody_Joints.html#MultiBody.Joints.UniversalSpherical"
>MultiBody.Joints.UniversalSpherical</A> rod1(
    animation=animation,
    showUniversalAxes=showUniversalAxes,
    rRod_ia=rRod1_ia,
    n1_a=n1_a,
    sphereDiameter=sphereDiameter,
    sphereColor=sphereColor,
    rodWidth=rod1Diameter,
    rodHeight=rod1Diameter,
    rodColor=rod1Color,
    cylinderLength=cylinderLength,
    cylinderDiameter=cylinderDiameter,
    cylinderColor=cylinderColor,
    kinematicConstraint=false);
  <A HREF="MultiBody_Parts.html#MultiBody.Parts.FixedTranslation"
>MultiBody.Parts.FixedTranslation</A> rod2(
    animation=animation,
    r=rRod2_ib,
    width=rod2Diameter,
    height=rod2Diameter,
    color=rod2Color);
  <A HREF="MultiBody_Sensors.html#MultiBody.Sensors.RelativeSensor"
>MultiBody.Sensors.RelativeSensor</A> relativeSensor(animation=false);
  Modelica.Blocks.Sources.Constant position_b(k=rRod2_ib);
<font color="blue">protected </font>
  SI.Position aux <font color="darkgreen">
    &quot;Denominator used to compute force in rod connecting universal and spherical joint&quot;</font>;
<font color="blue">equation </font>
  <font color="darkgreen">/* Compute the unknown force in rod1 connecting the universal and
     the spherical joint by a force balance at the prismatic joint
        0 = -prismatic.frame_b.f + frame_ib.f + frame_im.f - rod1.frame_b.f
     The force at rod1.frame_b is split into two parts:
        rod1.frame_b.f = Frames.resolve2(rod1.R_rel, rod1.f_b_a1 - rod1.f_rod*rod1.eRod_a)
     where rod1.f_rod is the unknown force in rod1.
     The condition is that the projection of the force in the prismatic
     joint along the axis of its translation axis is equal to the driving
     axis force in the flange:
       -prismatic.f = prismatic.e*prismatic.frame_b.f
     Therefore, we have with e=prismatic.e and f=prismatic.f
       -f = e*(frame_ib.f + frame_im.f
               - Frames.resolve2(rod1.R_rel, rod1.f_b_a1 - rod1.f_rod*rod1.eRod_a))
          = e*(frame_ib.f + frame_im.f - Frames.resolve2(rod1.R_rel, rod1.f_b_a1)
              + rod1.f_rod*Frames.resolve2(rod1.R_rel, rod1.eRod_a))
     Solving this equation for f_rod results in
       rod1.f_rod = -(f+e*(frame_ib.f + frame_im.f - Frames.resolve2(rod1.R_rel, rod1.f_b_a1))
                   /(e*Frames.resolve2(rod1.R_rel, rod1.eRod_a))
     Additionally, a guard against division by zero is introduced
  */</font>
  <font color="red">defineRoot</font>(frame_ib.R);
  aux = prismatic.e*<font color="red">Frames.resolve2</font>(rod1.R_rel, rod1.eRod_a);
  rod1.f_rod = (-prismatic.f - prismatic.e*(frame_ib.f + frame_im.f - <font color="red">
    Frames.resolve2</font>(rod1.R_rel, rod1.f_b_a1)))/<font color="red">noEvent</font>(<font color="blue">if </font><font color="red">abs</font>(aux) &lt; 1.e-10<font color="blue">
     then </font>1.e-10<font color="blue"> else </font>aux);
  <font color="darkgreen">// Measure power for test purposes</font>
  <font color="blue">if </font>checkTotalPower<font color="blue"> then</font>
    totalPower = frame_a.f*<font color="red">Frames.resolve2</font>(frame_a.R, <font color="red">der</font>(frame_a.r_0)) +
      frame_b.f*<font color="red">Frames.resolve2</font>(frame_b.R, <font color="red">der</font>(frame_b.r_0)) + frame_ia.f*<font color="red">
      Frames.resolve2</font>(frame_ia.R, <font color="red">der</font>(frame_ia.r_0)) + frame_ib.f*<font color="red">
      Frames.resolve2</font>(frame_ib.R, <font color="red">der</font>(frame_ib.r_0)) + frame_im.f*<font color="red">
      Frames.resolve2</font>(frame_im.R, <font color="red">der</font>(frame_im.r_0)) + frame_a.t*<font color="red">
      Frames.angularVelocity2</font>(frame_a.R, <font color="red">der</font>(frame_a.R)) + frame_b.t*<font color="red">
      Frames.angularVelocity2</font>(frame_b.R, <font color="red">der</font>(frame_b.R)) + frame_ia.t*<font color="red">
      Frames.angularVelocity2</font>(frame_ia.R, <font color="red">der</font>(frame_ia.R)) + frame_ib.t*<font color="red">
      Frames.angularVelocity2</font>(frame_ib.R, <font color="red">der</font>(frame_ib.R)) + frame_im.t*<font color="red">
      Frames.angularVelocity2</font>(frame_im.R, <font color="red">der</font>(frame_im.R)) + axis.f*<font color="red">der</font>(axis.s)
       + bearing.f*<font color="red">der</font>(bearing.s);
  <font color="blue">else</font>
    totalPower = 0;
  <font color="blue">end if</font>;
  <font color="darkgreen"></font>
  <font color="red">connect</font>(prismatic.frame_b, rod2.frame_a);
  <font color="red">connect</font>(rod2.frame_b, rod1.frame_b);
  <font color="red">connect</font>(prismatic.frame_a, frame_b);
  <font color="red">connect</font>(rod2.frame_a, frame_ib);
  <font color="red">connect</font>(rod1.frame_a, frame_a);
  <font color="red">connect</font>(relativeSensor.frame_b, frame_a);
  <font color="red">connect</font>(relativeSensor.frame_a, frame_b);
  <font color="red">connect</font>(rod2.frame_b, frame_im);
  <font color="red">connect</font>(rod1.frame_ia, frame_ia);
  <font color="red">connect</font>(position_b.outPort, prismatic.position_b);
  <font color="red">connect</font>(relativeSensor.outPort, prismatic.position_a);
  <font color="red">connect</font>(prismatic.axis, axis);
  <font color="red">connect</font>(prismatic.bearing, bearing);
<font color="blue">end </font>JointUSP;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE JointSSR<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><IMG SRC="MultiBody.Joints.Assemblies.JointSSRI.png" ALT="MultiBody.Joints.Assemblies.JointSSR" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="MultiBody.Joints.Assemblies.JointSSR"></A><A HREF="MultiBody_Joints_Assemblies.html#MultiBody.Joints.Assemblies"
>MultiBody.Joints.Assemblies</A>.JointSSR</H2>
<B>Spherical - spherical - revolute joint aggregation with mass (no constraints, no potential states)</B><p>
<IMG SRC="MultiBody.Joints.Assemblies.JointSSRD.png" ALT="MultiBody.Joints.Assemblies.JointSSR">
<H3>Information</H3>
<PRE></pre>
<p>
This component consists of a <b>spherical</b> joint 1 at frame_a, a <b>revolute</b>
joint at frame_b and a <b>spherical</b> joint 2 which is connected via rod 1
to the spherical joint 1 and via rod 2 to the revolute joint, see the default
animation in the following figure (the axes vectors are not part of the
default animation):
</p>
<p align="center">
<IMG SRC="../Images/Joints/JointSSR.png" ALT="model Joints.Assemblies.JointSSR">
</p>
<p>
Besides an optional point mass in the middle of rod 1,
this joint aggregation has no mass and no inertia,
and introduces neither constraints nor potential state variables.
It should be used in kinematic loops whenever possible since
the non-linear system of equations introduced by this joint aggregation
is solved <b>analytically</b> (i.e., a solution is always computed, if a
unique solution exists).
</p>
<p>
An additional <b>frame_ib</b> is present. It is <b>fixed</b> in rod 2
connecting the revolute and the spherical joint at the side of the revolute
joint that is connected to this rod (= rod2.frame_a = revolute.frame_a).
</p>
<p>
An additional <b>frame_im</b> is present. It is <b>fixed</b> in rod 2
connecting the revolute and the spherical joint at the side of spherical
joint 2 that is connected to this rod (= rod2.frame_b).
It is always parallel to <b>frame_ib</b>.
</p>
<p>
The easiest way to define the parameters of this joint is by moving the
MultiBody system in a <b>reference configuration</b> where <b>all frames</b>
of all components are <b>parallel</b> to each other (alternatively,
at least frame_b and frame_ib of the JointSSR joint
should be parallel to each other when defining an instance of this
component).
</p>
<pre> </PRE>
<H3>Parameters</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>animation</TD><TD>true</TD><TD>= true, if animation shall be enabled</TD></TR>
<TR><TD>showMass</TD><TD>true</TD><TD>= true, if point mass on rod 1 shall be shown (provided animation = true and rod1Mass &gt; 0)</TD></TR>
<TR><TD>rod1Length</TD><TD>1</TD><TD>Distance between the origins of the two spherical joints  [m]</TD></TR>
<TR><TD>rod1Mass</TD><TD>0</TD><TD>Mass of rod 1 (= point mass located in middle of rod connecting the two spherical joints) [kg]</TD></TR>
<TR><TD>n_b</TD><TD>{0,0,1}</TD><TD>Axis of revolute joint fixed and resolved in frame_b</TD></TR>
<TR><TD>rRod2_ib[3]</TD><TD>{1,0,0}</TD><TD>Vector from origin of frame_ib to spherical joint in the middle, resolved in frame_ib [m]</TD></TR>
<TR><TD>phi_offset</TD><TD>0</TD><TD>Relative angle offset of revolute joint (angle = phi(t) + from_deg(phi_offset)) [deg]</TD></TR>
<TR><TD>phi_guess</TD><TD>0</TD><TD>Select the configuration such that at initial time |phi(t0) - from_deg(phi_guess)| is minimal [deg]</TD></TR>
<TR><TD>sphereDiameter</TD><TD>world.defaultJointLength</TD><TD> Diameter of the spheres representing the two spherical joints [m]</TD></TR>
<TR><TD>sphereColor</TD><TD>MultiBody.Types.Defaults.JointColor</TD><TD> Color of the spheres representing the two spherical joints</TD></TR>
<TR><TD>rod1Diameter</TD><TD>sphereDiameter/Types.Defaults.JointRodDiameterFraction</TD><TD> Diameter of rod 1 connecting the two spherical joints [m]</TD></TR>
<TR><TD>rod1Color</TD><TD>MultiBody.Types.Defaults.RodColor</TD><TD> Color of rod 1 connecting the two spherical joint</TD></TR>
<TR><TD>rod2Diameter</TD><TD>rod1Diameter</TD><TD> Diameter of rod 2 connecting the revolute joint and spherical joint 2 [m]</TD></TR>
<TR><TD>rod2Color</TD><TD>rod1Color</TD><TD> Color of rod 2 connecting the revolute joint and spherical joint 2</TD></TR>
<TR><TD>revoluteDiameter</TD><TD>world.defaultJointWidth</TD><TD> Diameter of cylinder representing the revolute joint [m]</TD></TR>
<TR><TD>revoluteLength</TD><TD>world.defaultJointLength</TD><TD> Length of cylinder representing the revolute joint [m]</TD></TR>
<TR><TD>revoluteColor</TD><TD>MultiBody.Types.Defaults.JointColor</TD><TD> Color of cylinder representing the revolute joint</TD></TR>
<TR><TD>checkTotalPower</TD><TD>false</TD><TD> = true, if total power flowing into this component shall be determined (must be zero)</TD></TR>
</TABLE>
<H3>Modelica definition</H3>
<PRE>
<font color="blue">model</font> JointSSR <font color="darkgreen">
  &quot;Spherical - spherical - revolute joint aggregation with mass (no constraints, no potential states)&quot;</font>

  <font color="darkgreen"></font>
  <font color="blue">import </font>SI = Modelica.SIunits;
  <font color="blue">import </font>Cv = Modelica.SIunits.Conversions;
  <font color="darkgreen"></font>
  <font color="blue">extends </font><A HREF="MultiBody_Interfaces.html#MultiBody.Interfaces.PartialTwoFrames"
>MultiBody.Interfaces.PartialTwoFrames</A>;
  <A HREF="MultiBody_Interfaces.html#MultiBody.Interfaces.Frame_b"
>MultiBody.Interfaces.Frame_b</A> frame_ib;
  <A HREF="MultiBody_Interfaces.html#MultiBody.Interfaces.Frame_b"
>MultiBody.Interfaces.Frame_b</A> frame_im;
  Modelica.Mechanics.Rotational.Interfaces.Flange_a axis;
  Modelica.Mechanics.Rotational.Interfaces.Flange_b bearing;
  <font color="darkgreen"></font>
  <font color="blue">parameter </font>Boolean animation=true <font color="darkgreen">&quot;= true, if animation shall be enabled&quot;</font>;
  <font color="blue">parameter </font>Boolean showMass=true <font color="darkgreen">
    &quot;= true, if point mass on rod 1 shall be shown (provided animation = true and rod1Mass &gt; 0)&quot;</font>;
  <font color="blue">parameter </font>SI.Length rod1Length(min=Modelica.Constants.eps) = 1 <font color="darkgreen">
    &quot;Distance between the origins of the two spherical joints &quot;</font>;
  <font color="blue">parameter </font>SI.Mass rod1Mass=0 <font color="darkgreen">
    &quot;Mass of rod 1 (= point mass located in middle of rod connecting the two spherical joints)&quot;</font>;
  <font color="blue">parameter </font><A HREF="MultiBody_Types.html#MultiBody.Types.Axis"
>MultiBody.Types.Axis</A> n_b={0,0,1} <font color="darkgreen">
    &quot;Axis of revolute joint fixed and resolved in frame_b&quot;</font>;
  <font color="blue">parameter </font>SI.Position rRod2_ib[3]={1,0,0} <font color="darkgreen">
    &quot;Vector from origin of frame_ib to spherical joint in the middle, resolved in frame_ib&quot;</font>;
  <font color="blue">parameter </font>Cv.NonSIunits.Angle_deg phi_offset=0 <font color="darkgreen">
    &quot;Relative angle offset of revolute joint (angle = phi(t) + from_deg(phi_offset))&quot;</font>;
  <font color="blue">parameter </font>Cv.NonSIunits.Angle_deg phi_guess=0 <font color="darkgreen">
    &quot;Select the configuration such that at initial time |phi(t0) - from_deg(phi_guess)| is minimal&quot;</font>;
  <font color="blue">parameter </font>SI.Diameter sphereDiameter=world.defaultJointLength <font color="darkgreen">
    &quot;|Animation|if animation = true| Diameter of the spheres representing the two spherical joints&quot;</font>;
  <font color="blue">parameter </font><A HREF="MultiBody_Types.html#MultiBody.Types.Color"
>MultiBody.Types.Color</A> sphereColor=MultiBody.Types.Defaults.JointColor <font color="darkgreen">
    &quot;|Animation|if animation = true| Color of the spheres representing the two spherical joints&quot;</font>;
  <font color="blue">parameter </font>SI.Diameter rod1Diameter=sphereDiameter/Types.Defaults.
      JointRodDiameterFraction <font color="darkgreen">
    &quot;|Animation|if animation = true| Diameter of rod 1 connecting the two spherical joints&quot;</font>;
  <font color="blue">parameter </font><A HREF="MultiBody_Types.html#MultiBody.Types.Color"
>MultiBody.Types.Color</A> rod1Color=MultiBody.Types.Defaults.RodColor <font color="darkgreen">
    &quot;|Animation|if animation = true| Color of rod 1 connecting the two spherical joint&quot;</font>;
  <font color="blue">parameter </font>SI.Diameter rod2Diameter=rod1Diameter <font color="darkgreen">
    &quot;|Animation|if animation = true| Diameter of rod 2 connecting the revolute joint and spherical joint 2&quot;</font>;
  <font color="blue">parameter </font><A HREF="MultiBody_Types.html#MultiBody.Types.Color"
>MultiBody.Types.Color</A> rod2Color=rod1Color <font color="darkgreen">
    &quot;|Animation|if animation = true| Color of rod 2 connecting the revolute joint and spherical joint 2&quot;</font>;
  <font color="blue">parameter </font>SI.Diameter revoluteDiameter=world.defaultJointWidth <font color="darkgreen">
    &quot;|Animation|if animation = true| Diameter of cylinder representing the revolute joint&quot;</font>;
  <font color="blue">parameter </font>SI.Distance revoluteLength=world.defaultJointLength <font color="darkgreen">
    &quot;|Animation|if animation = true| Length of cylinder representing the revolute joint&quot;</font>;
  <font color="blue">parameter </font><A HREF="MultiBody_Types.html#MultiBody.Types.Color"
>MultiBody.Types.Color</A> revoluteColor=MultiBody.Types.Defaults.JointColor <font color="darkgreen">
    &quot;|Animation|if animation = true| Color of cylinder representing the revolute joint&quot;</font>;
  <font color="blue">parameter </font>Boolean checkTotalPower=false <font color="darkgreen">
    &quot;|Advanced|| = true, if total power flowing into this component shall be determined (must be zero)&quot;</font>;
  SI.Position aux <font color="darkgreen">
    &quot;Denominator used to compute force in rod connecting universal and spherical joint&quot;</font>;
  SI.Power totalPower <font color="darkgreen">
    &quot;Total power flowing into this element, if checkTotalPower=true (otherwise dummy)&quot;</font>;
  <font color="darkgreen"></font>
  <A HREF="MultiBody_Joints_Internal.html#MultiBody.Joints.Internal.RevoluteWithLengthConstraint"
>MultiBody.Joints.Internal.RevoluteWithLengthConstraint</A> revolute(
    animation=animation,
    lengthConstraint=rod1Length,
    n=n_b,
    phi_offset=phi_offset,
    phi_guess=phi_guess,
    cylinderDiameter=revoluteDiameter,
    cylinderLength=revoluteLength,
    cylinderColor=revoluteColor,
    axisTorqueBalance=false);
  <A HREF="MultiBody_Joints.html#MultiBody.Joints.SphericalSpherical"
>MultiBody.Joints.SphericalSpherical</A> rod1(
    animation=animation,
    showMass=showMass,
    m=rod1Mass,
    rodLength=rod1Length,
    rodDiameter=rod1Diameter,
    sphereDiameter=sphereDiameter,
    rodColor=rod1Color,
    kinematicConstraint=false,
    sphereColor=sphereColor);
  <A HREF="MultiBody_Parts.html#MultiBody.Parts.FixedTranslation"
>MultiBody.Parts.FixedTranslation</A> rod2(
    animation=animation,
    width=rod2Diameter,
    height=rod2Diameter,
    color=rod2Color,
    r=rRod2_ib);
  <A HREF="MultiBody_Sensors.html#MultiBody.Sensors.RelativeSensor"
>MultiBody.Sensors.RelativeSensor</A> relativeSensor(animation=false);
  Modelica.Blocks.Sources.Constant position_b(k=rRod2_ib);
<font color="blue">equation </font>
  <font color="red">defineRoot</font>(frame_ib.R);
  <font color="darkgreen">/* Compute the unknown force in the rod of the rod1 joint
     by a torque balance at the revolute joint:
       0 = frame_b.t + frame_ib.t + frame_im.t + cross(rRod2_ib, frame_im.f)
           + cross(rRod2_ib, -rod1.f_b_a1)
           + cross(rRod2_ib, Frames.resolve2(rod1.R_rel, rod1.f_rod*rod1.eRod_a))
     The condition is that the projection of the torque in the revolute
     joint along the axis of the revolute joint is equal to the driving
     axis torque in the flange:
       -revolute.tau = revolute.e*frame_b.t
     Therefore, we have with e=revolute.e and tau=revolute.tau
        tau = e*(frame_ib.t  + frame_im.t + cross(rRod2_ib, frame_im.f)
              + cross(rRod2_ib, -rod1.f_b_a1))
              + e*cross(rRod2_ib, Frames.resolve2(rod1.R_rel, rod1.f_rod*rod1.eRod_a))
            = e*(frame_ib.t + frame_im.t + cross(rRod2_ib, frame_im.f)
              + cross(rRod2_ib, -rod.f_b_a1))
              + rod1.f_rod*e*cross(rRod2_ib, Frames.resolve2(rod1.R_rel, rod1.eRod_a))
     Solving this equation for f_rod results in
       rod1.f_rod = (tau - e*(frame_ib.t + frame_im.t + cross(rRod2_ib, frame_im.f)
                   + cross(rRod2_ib, -rod1.f_b_a1)))
                   / (cross(e,rRod2_ib)*Frames.resolve2(rod1.R_rel, rod1.eRod_a)))
     Additionally, a guard against division by zero is introduced
  */</font>
  <font color="darkgreen"></font>
  aux = <font color="red">cross</font>(revolute.e, rRod2_ib)*<font color="red">Frames.resolve2</font>(rod1.R_rel, rod1.eRod_a);
  rod1.f_rod = (-revolute.tau - revolute.e*(frame_ib.t + frame_im.t + <font color="red">cross</font>(
    rRod2_ib, frame_im.f) - <font color="red">cross</font>(rRod2_ib, <font color="red">Frames.resolve2</font>(rod1.R_rel, rod1.
    f_b_a1))))/<font color="red">noEvent</font>(<font color="blue">if </font><font color="red">abs</font>(aux) &lt; 1.e-10<font color="blue"> then </font>1.e-10<font color="blue"> else </font>aux);
  <font color="darkgreen"></font>
  <font color="darkgreen">// Measure power for test purposes</font>
  <font color="blue">if </font>checkTotalPower<font color="blue"> then</font>
    totalPower = frame_a.f*<font color="red">Frames.resolve2</font>(frame_a.R, <font color="red">der</font>(frame_a.r_0)) +
      frame_b.f*<font color="red">Frames.resolve2</font>(frame_b.R, <font color="red">der</font>(frame_b.r_0)) + frame_ib.f*<font color="red">
      Frames.resolve2</font>(frame_ib.R, <font color="red">der</font>(frame_ib.r_0)) + frame_im.f*<font color="red">
      Frames.resolve2</font>(frame_im.R, <font color="red">der</font>(frame_im.r_0)) + frame_a.t*<font color="red">
      Frames.angularVelocity2</font>(frame_a.R, <font color="red">der</font>(frame_a.R)) + frame_b.t*<font color="red">
      Frames.angularVelocity2</font>(frame_b.R, <font color="red">der</font>(frame_b.R)) + frame_ib.t*<font color="red">
      Frames.angularVelocity2</font>(frame_ib.R, <font color="red">der</font>(frame_ib.R)) + frame_im.t*<font color="red">
      Frames.angularVelocity2</font>(frame_im.R, <font color="red">der</font>(frame_im.R)) + axis.tau*<font color="red">der</font>(axis.
      phi) + bearing.tau*<font color="red">der</font>(bearing.phi) + (-rod1Mass)*(<font color="red">der</font>(rod1.v_CM_0) - <font color="red">
      world.gravityAcceleration</font>(rod1.r_CM_0))*rod1.v_CM_0;
  <font color="blue">else</font>
    totalPower = 0;
  <font color="blue">end if</font>;
  <font color="darkgreen"></font>
  <font color="red">connect</font>(revolute.frame_b, rod2.frame_a);
  <font color="red">connect</font>(rod2.frame_b, rod1.frame_b);
  <font color="red">connect</font>(revolute.frame_a, frame_b);
  <font color="red">connect</font>(rod2.frame_a, frame_ib);
  <font color="red">connect</font>(rod1.frame_a, frame_a);
  <font color="red">connect</font>(relativeSensor.frame_b, frame_a);
  <font color="red">connect</font>(relativeSensor.frame_a, frame_b);
  <font color="red">connect</font>(relativeSensor.outPort, revolute.position_a);
  <font color="red">connect</font>(position_b.outPort, revolute.position_b);
  <font color="red">connect</font>(revolute.axis, axis);
  <font color="red">connect</font>(revolute.bearing, bearing);
  <font color="red">connect</font>(rod2.frame_b, frame_im);
<font color="blue">end </font>JointSSR;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE JointRRP<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><IMG SRC="MultiBody.Joints.Assemblies.JointRRPI.png" ALT="MultiBody.Joints.Assemblies.JointRRP" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="MultiBody.Joints.Assemblies.JointRRP"></A><A HREF="MultiBody_Joints_Assemblies.html#MultiBody.Joints.Assemblies"
>MultiBody.Joints.Assemblies</A>.JointRRP</H2>
<B>Planar revolute - revolute - prismatic joint aggregation (no constraints, no potential states)</B><p>
<IMG SRC="MultiBody.Joints.Assemblies.JointRRPD.png" ALT="MultiBody.Joints.Assemblies.JointRRP">
<H3>Information</H3>
<PRE></pre>
<p>
This component consists of <b>2 revolute</b> joints with parallel
axes of rotation that and a <b>prismatic</b> joint with a translational
axis that is orthogonal to the revolute joint axes, see the default
animation in the following figure (the axes vectors are not part of the
default animation):
</p>
<p align="center">
<IMG SRC="../Images/Joints/JointRRP.png" ALT="model Joints.Assemblies.JointRRP">
</p>
<p>
This joint aggregation introduces neither constraints nor state variables and
should therefore be used in kinematic loops whenever possible to
avoid non-linear systems of equations. It is only meaningful to
use this component in <b>planar loops</b>. Basically, the position
and orientation of the 3 joints as well as of frame_ia, frame_ib, and
frame_im are calculated by solving analytically a non-linear equation,
given the position and orientation at frame_a and at frame_b.
</p>
<p>
Connector <b>frame_a</b> is the "left" side of the first revolute joint
whereas <b>frame_ia</b> is the "right side of this revolute joint, fixed in rod 1.
Connector <b>frame_b</b> is the "right" side of the prismatic joint
whereas <b>frame_ib</b> is the "left" side of this prismatic joint, fixed in rod 2.
Finally, connector <b>frame_im</b> is the connector at the "right" side
of the revolute joint in the middle, fixed in rod 2. The frames
frame_b, frame_ib, frame_im are always parallel to each other.
</p>
<p>
The easiest way to define the parameters of this joint is by moving the
MultiBody system in a <b>reference configuration</b> where <b>all frames</b>
of all components are <b>parallel</b> to each other (alternatively,
at least frame_a, frame_ia, frame_im, frame_ib, frame_b of the JointRRP joint
should be parallel to each other when defining an instance of this
component).
</p>
<p>
Basically, the JointRRP model consists internally of a universal -
spherical - prismatic joint aggregation (= JointUSP). In a planar
loop this will behave as if 2 revolute joints with parallel axes
and 1 prismatic joint are connected by rigid rods.
</p>
<pre> </PRE>
<H3>Parameters</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>animation</TD><TD>true</TD><TD>= true, if animation shall be enabled</TD></TR>
<TR><TD>n_a</TD><TD>{0,0,1}</TD><TD>Axes of the two revolute joints resolved in frame_a (both axes are parallel to each other)</TD></TR>
<TR><TD>n_b</TD><TD>{-1,0,0}</TD><TD>Axis of prismatic joint fixed and resolved in frame_b (must be orthogonal to revolute joint axes)</TD></TR>
<TR><TD>rRod1_ia[3]</TD><TD>{1,0,0}</TD><TD>Vector from origin of frame_a to revolute joint in the middle, resolved in frame_ia [m]</TD></TR>
<TR><TD>rRod2_ib[3]</TD><TD>{-1,0,0}</TD><TD>Vector from origin of frame_ib to revolute joint in the middle, resolved in frame_ib (frame_ib is parallel to frame_b) [m]</TD></TR>
<TR><TD>s_offset</TD><TD>0</TD><TD>Relative distance offset of prismatic joint (distance between the prismatic joint frames = s(t) + s_offset) [m]</TD></TR>
<TR><TD>s_guess</TD><TD>0</TD><TD>Select the configuration such that at initial time |s(t0)-s_guess| is minimal [m]</TD></TR>
<TR><TD>cylinderLength</TD><TD>world.defaultJointLength</TD><TD> Length of cylinders representing the revolute joints [m]</TD></TR>
<TR><TD>cylinderDiameter</TD><TD>world.defaultJointWidth</TD><TD> Diameter of cylinders representing the revolute joints [m]</TD></TR>
<TR><TD>cylinderColor</TD><TD>MultiBody.Types.Defaults.JointColor</TD><TD> Color of cylinders representing the revolute joints</TD></TR>
<TR><TD>boxWidthDirection</TD><TD>{0,1,0}</TD><TD> Vector in width direction of prismatic joint, resolved in frame_b</TD></TR>
<TR><TD>boxWidth</TD><TD>world.defaultJointWidth</TD><TD> Width of prismatic joint box [m]</TD></TR>
<TR><TD>boxHeight</TD><TD>boxWidth</TD><TD> Height of prismatic joint box [m]</TD></TR>
<TR><TD>boxColor</TD><TD>cylinderColor</TD><TD> Color of prismatic joint box</TD></TR>
<TR><TD>rodDiameter</TD><TD>1.1*cylinderDiameter</TD><TD> Diameter of the two rods connecting the joints [m]</TD></TR>
<TR><TD>rodColor</TD><TD>MultiBody.Types.Defaults.RodColor</TD><TD> Color of the two rods connecting the joints</TD></TR>
<TR><TD>checkTotalPower</TD><TD>false</TD><TD> = true, if total power flowing into this component shall be determined (must be zero)</TD></TR>
</TABLE>
<H3>Modelica definition</H3>
<PRE>
<font color="blue">model</font> JointRRP <font color="darkgreen">
  &quot;Planar revolute - revolute - prismatic joint aggregation (no constraints, no potential states)&quot;</font>

  <font color="darkgreen"></font>
  <font color="blue">import </font>SI = Modelica.SIunits;
  <font color="blue">import </font>Cv = Modelica.SIunits.Conversions;
  <font color="darkgreen"></font>
  <font color="blue">extends </font><A HREF="MultiBody_Interfaces.html#MultiBody.Interfaces.PartialTwoFrames"
>MultiBody.Interfaces.PartialTwoFrames</A>;
  <font color="darkgreen"></font>
  <A HREF="MultiBody_Interfaces.html#MultiBody.Interfaces.Frame_a"
>MultiBody.Interfaces.Frame_a</A> frame_ia;
  <A HREF="MultiBody_Interfaces.html#MultiBody.Interfaces.Frame_b"
>MultiBody.Interfaces.Frame_b</A> frame_im;
  <A HREF="MultiBody_Interfaces.html#MultiBody.Interfaces.Frame_b"
>MultiBody.Interfaces.Frame_b</A> frame_ib;
  Modelica.Mechanics.Translational.Interfaces.Flange_a axis;
  Modelica.Mechanics.Translational.Interfaces.Flange_b bearing;
  <font color="darkgreen"></font>
  <font color="blue">parameter </font>Boolean animation=true <font color="darkgreen">&quot;= true, if animation shall be enabled&quot;</font>;
  <font color="blue">parameter </font><A HREF="MultiBody_Types.html#MultiBody.Types.Axis"
>MultiBody.Types.Axis</A> n_a={0,0,1} <font color="darkgreen">
    &quot;Axes of the two revolute joints resolved in frame_a (both axes are parallel to each other)&quot;</font>;
  <font color="blue">parameter </font><A HREF="MultiBody_Types.html#MultiBody.Types.Axis"
>MultiBody.Types.Axis</A> n_b={-1,0,0} <font color="darkgreen">
    &quot;Axis of prismatic joint fixed and resolved in frame_b (must be orthogonal to revolute joint axes)&quot;</font>;
  <font color="blue">parameter </font>SI.Position rRod1_ia[3]={1,0,0} <font color="darkgreen">
    &quot;Vector from origin of frame_a to revolute joint in the middle, resolved in frame_ia&quot;</font>;
  <font color="blue">parameter </font>SI.Position rRod2_ib[3]={-1,0,0} <font color="darkgreen">
    &quot;Vector from origin of frame_ib to revolute joint in the middle, resolved in frame_ib (frame_ib is parallel to frame_b)&quot;</font>;
  <font color="blue">parameter </font>SI.Position s_offset=0 <font color="darkgreen">
    &quot;Relative distance offset of prismatic joint (distance between the prismatic joint frames = s(t) + s_offset)&quot;</font>;
  <font color="blue">parameter </font>SI.Position s_guess=0 <font color="darkgreen">
    &quot;Select the configuration such that at initial time |s(t0)-s_guess| is minimal&quot;</font>;
  <font color="blue">parameter </font>SI.Distance cylinderLength=world.defaultJointLength <font color="darkgreen">
    &quot;|Animation|if animation = true| Length of cylinders representing the revolute joints&quot;</font>;
  <font color="blue">parameter </font>SI.Distance cylinderDiameter=world.defaultJointWidth <font color="darkgreen">
    &quot;|Animation|if animation = true| Diameter of cylinders representing the revolute joints&quot;</font>;
  <font color="blue">parameter </font><A HREF="MultiBody_Types.html#MultiBody.Types.Color"
>MultiBody.Types.Color</A> cylinderColor=MultiBody.Types.Defaults.JointColor <font color="darkgreen">
    &quot;|Animation|if animation = true| Color of cylinders representing the revolute joints&quot;</font>;
  <font color="blue">parameter </font><A HREF="MultiBody_Types.html#MultiBody.Types.Axis"
>MultiBody.Types.Axis</A> boxWidthDirection={0,1,0} <font color="darkgreen">
    &quot;|Animation|if animation = true| Vector in width direction of prismatic joint, resolved in frame_b&quot;</font>;
  <font color="blue">parameter </font>SI.Distance boxWidth=world.defaultJointWidth <font color="darkgreen">
    &quot;|Animation|if animation = true| Width of prismatic joint box&quot;</font>;
  <font color="blue">parameter </font>SI.Distance boxHeight=boxWidth <font color="darkgreen">
    &quot;|Animation|if animation = true| Height of prismatic joint box&quot;</font>;
  <font color="blue">parameter </font><A HREF="MultiBody_Types.html#MultiBody.Types.Color"
>MultiBody.Types.Color</A> boxColor=cylinderColor <font color="darkgreen">
    &quot;|Animation|if animation = true| Color of prismatic joint box&quot;</font>;
  <font color="blue">parameter </font>SI.Diameter rodDiameter=1.1*cylinderDiameter <font color="darkgreen">
    &quot;|Animation|if animation = true| Diameter of the two rods connecting the joints&quot;</font>;
  <font color="blue">parameter </font><A HREF="MultiBody_Types.html#MultiBody.Types.Color"
>MultiBody.Types.Color</A> rodColor=MultiBody.Types.Defaults.RodColor <font color="darkgreen">
    &quot;|Animation|if animation = true| Color of the two rods connecting the joints&quot;</font>;
  <font color="blue">parameter </font>Boolean checkTotalPower=false <font color="darkgreen">
    &quot;|Advanced|| = true, if total power flowing into this component shall be determined (must be zero)&quot;</font>;
  <font color="blue">final </font><font color="blue">parameter </font>Real e_a[3]=<font color="red">Frames.normalize</font>(n_a) <font color="darkgreen">
    &quot;Unit vector along axes of rotations, resolved in frame_a&quot;</font>;
  <font color="blue">final </font><font color="blue">parameter </font>Real e_ia[3]=jointUSP.e2_ia <font color="darkgreen">
    &quot;Unit vector along axes of rotations, resolved in frame_ia&quot;</font>;
  <font color="blue">final </font><font color="blue">parameter </font>Real e_im[3](<font color="blue">each </font>fixed=false) <font color="darkgreen">
    &quot;Unit vector along axes of rotations, resolved in frame_im&quot;</font>;
  <font color="blue">final </font><font color="blue">parameter </font>Real e_b[3]=jointUSP.prismatic.e <font color="darkgreen">
    &quot;Unit vector along axes of translation of the prismatic joint, resolved in frame_b and frame_ib&quot;</font>;
  SI.Power totalPower=jointUSP.totalPower <font color="darkgreen">
    &quot;Total power flowing into this element, if checkTotalPower=true (otherwise dummy)&quot;</font>;
  <font color="darkgreen"></font>
  <font color="darkgreen"></font>
  <A HREF="MultiBody_Joints_Assemblies.html#MultiBody.Joints.Assemblies.JointUSP"
>JointUSP</A> jointUSP(
    animation=false,
    showUniversalAxes=false,
    n1_a=n_a,
    n_b=n_b,
    s_offset=s_offset,
    s_guess=s_guess,
    rRod1_ia=rRod1_ia,
    rRod2_ib=rRod2_ib,
    checkTotalPower=checkTotalPower);
  <font color="darkgreen"></font>
<font color="blue">protected </font>
  <font color="blue">parameter </font>Integer ndim=<font color="blue">if </font>world.enableAnimation<font color="blue"> and </font>animation<font color="blue"> then </font>1<font color="blue"> else </font>0;
  <A HREF="MultiBody_Visualizers_Advanced.html#MultiBody.Visualizers.Advanced.Shape"
>Visualizers.Advanced.Shape</A> shape_rev1[ndim](
    <font color="blue">each </font>shapeType=&quot;cylinder&quot;,
    <font color="blue">each </font>color=cylinderColor,
    <font color="blue">each </font>length=cylinderLength,
    <font color="blue">each </font>width=cylinderDiameter,
    <font color="blue">each </font>height=cylinderDiameter,
    <font color="blue">each </font>lengthDirection=e_a,
    <font color="blue">each </font>widthDirection={0,1,0},
    <font color="blue">each </font>r_shape=-e_a*(cylinderLength/2),
    <font color="blue">each </font>r=frame_a.r_0,
    <font color="blue">each </font>R=frame_a.R);
  <A HREF="MultiBody_Visualizers_Advanced.html#MultiBody.Visualizers.Advanced.Shape"
>Visualizers.Advanced.Shape</A> shape_rev2[ndim](
    <font color="blue">each </font>shapeType=&quot;cylinder&quot;,
    <font color="blue">each </font>color=cylinderColor,
    <font color="blue">each </font>length=cylinderLength,
    <font color="blue">each </font>width=cylinderDiameter,
    <font color="blue">each </font>height=cylinderDiameter,
    <font color="blue">each </font>lengthDirection=e_im,
    <font color="blue">each </font>widthDirection={0,1,0},
    <font color="blue">each </font>r_shape=-e_im*(cylinderLength/2),
    <font color="blue">each </font>r=frame_im.r_0,
    <font color="blue">each </font>R=frame_im.R);
  <A HREF="MultiBody_Visualizers_Advanced.html#MultiBody.Visualizers.Advanced.Shape"
>Visualizers.Advanced.Shape</A> shape_prism[ndim](
    <font color="blue">each </font>shapeType=&quot;box&quot;,
    <font color="blue">each </font>color=boxColor,
    <font color="blue">each </font>length=jointUSP.prismatic.distance,
    <font color="blue">each </font>width=boxWidth,
    <font color="blue">each </font>height=boxHeight,
    <font color="blue">each </font>lengthDirection=e_b,
    <font color="blue">each </font>widthDirection=e_im,
    <font color="blue">each </font>r=frame_b.r_0,
    <font color="blue">each </font>R=frame_b.R);
  <A HREF="MultiBody_Visualizers_Advanced.html#MultiBody.Visualizers.Advanced.Shape"
>Visualizers.Advanced.Shape</A> shape_rod1[ndim](
    <font color="blue">each </font>shapeType=&quot;cylinder&quot;,
    <font color="blue">each </font>color=rodColor,
    <font color="blue">each </font>length=<font color="red">Frames.length</font>(rRod1_ia),
    <font color="blue">each </font>width=rodDiameter,
    <font color="blue">each </font>height=rodDiameter,
    <font color="blue">each </font>lengthDirection=rRod1_ia,
    <font color="blue">each </font>widthDirection=e_ia,
    <font color="blue">each </font>r=frame_ia.r_0,
    <font color="blue">each </font>R=frame_ia.R);
  <A HREF="MultiBody_Visualizers_Advanced.html#MultiBody.Visualizers.Advanced.Shape"
>Visualizers.Advanced.Shape</A> shape_rod2[ndim](
    <font color="blue">each </font>shapeType=&quot;cylinder&quot;,
    <font color="blue">each </font>color=rodColor,
    <font color="blue">each </font>length=<font color="red">Frames.length</font>(rRod2_ib),
    <font color="blue">each </font>width=rodDiameter,
    <font color="blue">each </font>height=rodDiameter,
    <font color="blue">each </font>lengthDirection=rRod2_ib,
    <font color="blue">each </font>widthDirection=e_b,
    <font color="blue">each </font>r=frame_ib.r_0,
    <font color="blue">each </font>R=frame_ib.R);
<font color="blue">initial </font><font color="blue">equation </font>
  e_im = <font color="red">Frames.resolve2</font>(frame_im.R, <font color="red">Frames.resolve1</font>(frame_a.R, e_a));
<font color="blue">equation </font>
  <font color="red">connect</font>(jointUSP.frame_a, frame_a);
  <font color="red">connect</font>(jointUSP.frame_b, frame_b);
  <font color="red">connect</font>(jointUSP.frame_ia, frame_ia);
  <font color="red">connect</font>(jointUSP.frame_im, frame_im);
  <font color="red">connect</font>(jointUSP.frame_ib, frame_ib);
  <font color="red">connect</font>(jointUSP.axis, axis);
  <font color="red">connect</font>(jointUSP.bearing, bearing);
<font color="blue">end </font>JointRRP;
</PRE>
<HR>
<address>HTML-documentation generated by <a href="http://www.dynasim.se/">Dymola</a> Wed Oct 29 09:12:33 2003
.
</address></BODY>
</HTML>
